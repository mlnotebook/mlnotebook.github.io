<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cnn on Machine Learning Notebook</title>
    <link>/tags/cnn/index.xml</link>
    <description>Recent content in Cnn on Machine Learning Notebook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/tags/cnn/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Generative Adversarial Network (GAN) in TensorFlow - Part 2</title>
      <link>/post/GAN2/</link>
      <pubDate>Wed, 12 Jul 2017 11:59:45 +0100</pubDate>
      
      <guid>/post/GAN2/</guid>
      <description>&lt;p&gt;This tutorial will provide the data that we will use when using our Generative Adversarial Networks. It will also take an overview on the structure of the necessary code for creating a GAN and provide some skeleton code which we can work on in the next post. If you&amp;rsquo;re not up to speed on GANs, please do read the brief introduction in &lt;a href=&#34;/post/GAN1&#34; title=&#34;GAN Part 1 - Some Background and Mathematics&#34;&gt;Part 1&lt;/a&gt; of this series on Generative Adversarial Networks.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;intro&#34;&gt; Introduction &lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ve look at &lt;a href=&#34;/post/GAN1&#34; title=&#34;GAN Part 1 - Some Background and Mathematics&#34;&gt;how a GAN works&lt;/a&gt;  and how it is trained, but how do we implement this in Python? There are several stages to this task:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create some initial functions that will read in our training data&lt;/li&gt;
&lt;li&gt;Create some functions that will perform the steps in the CNN&lt;/li&gt;
&lt;li&gt;Write a &lt;code&gt;class&lt;/code&gt; that will hold our GAN and all of its important methods&lt;/li&gt;
&lt;li&gt;Put these together in a script that we can run to train the GAN&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The way I&amp;rsquo;d like to go through this process (in the next post) is by taking the network piece by piece as it would be called by the program. I think this is important to help to understand the flow of the data through the network. The code that I&amp;rsquo;ve used for the basis of these tutorials is from &lt;a href=&#34;https://github.com/carpedm20/DCGAN-tensorflow&#34; title=&#34;carpedm20/DCGAN-tensorflow&#34;&gt;carpedm20&amp;rsquo;s DCGAN-tensorflow repository&lt;/a&gt;, with a lot of influence from other sources including &lt;a href=&#34;http://bamos.github.io/2016/08/09/deep-completion/#ml-heavy-generative-adversarial-net-gan-building-blocks&#34; title=&#34;bamos.github.io&#34;&gt;this blog from B. Amos&lt;/a&gt;. I&amp;rsquo;m hoping that by  putting this together in several posts, and fleshing out the code, it will become clearer.&lt;/p&gt;

&lt;h2 id=&#34;skeletons&#34;&gt; Skeleton Code &lt;/h2&gt;

&lt;p&gt;We will structure our code into 4 separate &lt;code&gt;.py&lt;/code&gt; files. Each file represents one of the 4 stages set out above:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;/docs/GAN/gantut_imgfuncs.py&#34; title=&#34;gantut_imgfuncs.py&#34;&gt;&lt;code&gt;gantut_imgfuncs.py&lt;/code&gt;&lt;/a&gt;: holds the image-related functions&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/docs/GAN/gantut_datafuncs.py&#34; title=&#34;gantut_datafuncs.py&#34;&gt;&lt;code&gt;gantut_datafuncs.py&lt;/code&gt;&lt;/a&gt;: contains the data-related functions&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/docs/GAN/gantut_gan.py&#34; title=&#34;gantut_gan.py&#34;&gt;&lt;code&gt;gantut_gan.py&lt;/code&gt;&lt;/a&gt;: is where we define the GAN &lt;code&gt;class&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/docs/GAN/gantut_trainer.py&#34; title=&#34;gantut_trainer.py&#34;&gt;&lt;code&gt;gantut_trainer.py&lt;/code&gt;&lt;/a&gt;: is the script that we will call in order to train the GAN&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For our project, let&amp;rsquo;s use the working directory &lt;code&gt;~/GAN&lt;/code&gt;. Download these skeletons using the links above into `~/GAN&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;If you look through each of these files, you will see that they contain only a comment for each function/class and the line defining each function/method. Each of these will have to be completed when we go through the next couple of posts. In the remainder of this post, we will take a look at the dataset that we will be using and prepare the images.&lt;/p&gt;

&lt;h2 id=&#34;dataset&#34;&gt; Dataset&lt;/h2&gt;

&lt;p&gt;We clearly need to have some training data to hand to be able to make this work. Several posts have used databases of faces or even the MNIST digit-classification dataset. In our tutorial, we will be using faces - I find this very interesting as it allows the computer to create photo-realistic images of people that don&amp;rsquo;t actually exist!&lt;/p&gt;

&lt;p&gt;To get the dataset prepared we need to download it, and then pre-process the images so that they will be small enough to use in our GAN.&lt;/p&gt;

&lt;h3 id=&#34;dataset-download&#34;&gt; Download &lt;/h3&gt;

&lt;p&gt;We are going to use the &lt;a href=&#34;http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html&#34; title=&#34;CelebA&#34;&gt;CelebA&lt;/a&gt; databse. Here is a direct link to the GoogleDrive which stores the data: &lt;a href=&#34;https://drive.google.com/drive/folders/0B7EVK8r0v71pTUZsaXdaSnZBZzg&#34;&gt;https://drive.google.com/drive/folders/0B7EVK8r0v71pTUZsaXdaSnZBZzg&lt;/a&gt;. You will want to go to the &amp;ldquo;img&amp;rdquo; folder and download the &lt;a href=&#34;https://drive.google.com/open?id=0B7EVK8r0v71pZjFTYXZWM3FlRnM&#34; title=&#34;img_align_celeba.zip&#34;&gt;&amp;ldquo;img_align_celeba.zip&amp;rdquo;&lt;/a&gt; file. Direct download link should be:&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;a href=&#34;https://drive.google.com/open?id=0B7EVK8r0v71pZjFTYXZWM3FlRnM&#34; title=&#34;img_align_celeba.zip&#34;&gt;img_align_celeba.zip (1.3GB)&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Download and extract this folder into &lt;code&gt;~/GAN/raw_images&lt;/code&gt; to find it contains 200,000+ examples of celebrity faces. Even though the &lt;code&gt;.zip&lt;/code&gt; says &amp;lsquo;align&amp;rsquo; in the name, we still need to resize the images and thus may need to realign them too.&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;http://mmlab.ie.cuhk.edu.hk/projects/celeba/overview.png&#34; width=&#34;75%&#34; title=&#34;CelebA Database&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 1&lt;/font&gt;: Examples from the CelebA Database. Source: &lt;a href=&#34;http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html&#34; alt=&#34;CelebA&#34;&gt;CelebA&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h3 is=&#34;dataset-process&#34;&gt; Processing &lt;/h3&gt;

&lt;p&gt;To process this volume of images, we need an automated method for resizing and cropping. We will use &lt;a href=&#34;http://cmusatyalab.github.io/openface/&#34; title=&#34;OpenFace&#34;&gt;OpenFace&lt;/a&gt;. Specifically, there&amp;rsquo;s a small tool we will want to use from this.&lt;/p&gt;

&lt;p&gt;Open a terminal, navigate to or create your working directory (we&amp;rsquo;ll use &lt;code&gt;~/GAN&lt;/code&gt; and follow the instructions below to clone OpenFace and get the Python wrapping sorted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/GAN
git clone https://github.com/cmusatyalab/openface.git openface
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cloning complete, move into the &lt;code&gt;openface&lt;/code&gt; folder and install the requirements (handily they&amp;rsquo;re in requirements.txt, so do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ./openface
sudo pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Installation complete (make sure you use sudo to get the permissions to install). Next we want to install the models that we can use with Python:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./models/get-models.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This make take a short while. When this is done, you may want to update Scipy. This is because the requirements.txt wants a previous version to the most recent. Easily fixed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pip install --upgrade scipy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have access to the Python tool that will do the aligning and cropping of our faces. This is an important step to ensure that all images going into the network are the same dimensions, but also so that the network can learn the faces well (there&amp;rsquo;s no point in having eyes at the bottom of an image, or a face that&amp;rsquo;s half out of the field of view).&lt;/p&gt;

&lt;p&gt;In our working directory `~/GAN&amp;rsquo;, do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./openface/util/align-dlib.py ./raw_images align innerEyesAndBottomLip ./aligned --size 64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will &lt;code&gt;align&lt;/code&gt; all of the &lt;code&gt;innerEyesAndBottomLip&lt;/code&gt; of the images in &lt;code&gt;./raw_images&lt;/code&gt;, crop them to &lt;code&gt;64&lt;/code&gt; x &lt;code&gt;64&lt;/code&gt; and put them in &lt;code&gt;./aligned&lt;/code&gt;. This will take a long time (for 200,000+ images!).&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;/img/CNN/resized_celeba.png&#34; width=&#34;50%&#34; title=&#34;Cropped and Resized CelebA&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 2&lt;/font&gt;: Examples of aligned, cropped and resized images from the &lt;a href=&#34;http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html&#34; alt=&#34;CelebA&#34;&gt;CelebA&lt;/a&gt; database.
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;That&amp;rsquo;s it! Now we will have a good training set to use with our network. We also have the skeletons that we can build up to form our GAN. Our next post will look at the functions that will read-in the images for use with the GAN and begin to work on the GAN &lt;code&gt;class&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Generative Adversarial Network (GAN) in TensorFlow - Part 1</title>
      <link>/post/GAN1/</link>
      <pubDate>Tue, 11 Jul 2017 09:15:54 +0100</pubDate>
      
      <guid>/post/GAN1/</guid>
      <description>&lt;p&gt;We&amp;rsquo;ve seen that CNNs can learn the content of an image for classificationi purposes, but what else can they do? This tutorial will look at the Generative Adversarial Network (GAN) which is able to learn from a set of images and create an entirely new &amp;lsquo;fake&amp;rsquo; image which isn&amp;rsquo;t in the training set. Why? By the end of this tutorial you&amp;rsquo;ll get know why this might be done and how to do it.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;intro&#34;&gt;  Introduction &lt;/h2&gt;

&lt;p&gt;Generative Adversarial Networks (GANs) were proposed by Ian Goodfellow &lt;em&gt;et al&lt;/em&gt; in 2014 at annual the Neural Information and Processing Systems (NIPS) conference. The original paper &lt;a href=&#34;https://arxiv.org/pdf/1406.2661 &amp;quot;Generative Adversarial Nets (2014&#34;&gt;is available on Arxiv&lt;/a&gt;&amp;rdquo;) along with a later tutorial by Goodfellow delivered at NIPS in 2016 &lt;a href=&#34;https://arxiv.org/pdf/1701.00160&#34; title=&#34;NIPS 2016 Tutorial: Generative Adversarial Networks&#34;&gt;here&lt;/a&gt;. I&amp;rsquo;ve read both of these (and others) as well as taking a look at other tutorials but sometimes things just weren&amp;rsquo;t clear enough for me. &lt;a href=&#34;http://bamos.github.io/2016/08/09/deep-completion/#ml-heavy-generative-adversarial-net-gan-building-blocks&#34; title=&#34;bamos.github.io&#34;&gt;This blog from B. Amos&lt;/a&gt; has been helpful in getting my thoughts organised on this series, and hopefully I can build on this a little and make things more concrete.&lt;/p&gt;

&lt;h3&gt;What&#39;s a GAN?&lt;/h3&gt;

&lt;p&gt;GANs  are used in a number of ways, for example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;to generate new images based upon some training data. For our tutorial, we will train with a database of faces and ask the network to produce a new face.&lt;/li&gt;
&lt;li&gt;to do &amp;lsquo;inpainting&amp;rsquo; or &amp;lsquo;image completion&amp;rsquo;. This is where part of a scene may be missing and we wish to recover the full image. It could be that we want to remove parts of the image e.g. people, and fill-in the background.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are two components in a GAN which try to work against each other (hence the &amp;lsquo;adversarial&amp;rsquo; part).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Generator (&lt;em&gt;G&lt;/em&gt;) starts off by creating a very noisy image based upon some random input data. Its job is to try to come up with images that are as real as possible.&lt;/li&gt;
&lt;li&gt;The Discriminator (&lt;em&gt;D&lt;/em&gt;) is trying to determine whether an image is real or fake.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Though these two are the primary components of the network, we also need to write some functions for importing data and dealing with the training of this two-stage network. Part 1 of this tutorial will go through some background and mathematics, in Part 2 we will do some general housekeeping and get us prepared to write the main model of our network in Part 3.&lt;/p&gt;

&lt;h2 id=&#34;maths&#34;&gt; Background &lt;/h2&gt;

&lt;p&gt;There are a number of situations where you may want to use a GAN. A common task is for image completion or &amp;lsquo;in-painting&amp;rsquo;. This would be where we have an image and would like to remove some obstruction or imperfection by replacing it with the background. Maybe there&amp;rsquo;s a lovely holiday photo of beautiful scenery, but there are some people you don&amp;rsquo;t know spoiling the view. Figure 1 shows an example of the result of image completion using PhotoShop on such an image.&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;https://farm5.staticflickr.com/4115/4756059924_e26ae12e46_b.jpg&#34; width=&#34;100%&#34; alt=&#34;Image Completion Example&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 1&lt;/font&gt;: Removal of unwated parts of a scene with image completion. Source: &lt;a href=&#34;https://www.flickr.com/photos/littleredelf/4756059924/in/photostream/&#34; alt=&#34;littleredelf&#34;&gt;Flickr:littleredelf&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;We have a couple of options if we want to try and do this kind of image completion ourselves. Let&amp;rsquo;s say we draw around an area we want to change:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If we&amp;rsquo;ve never seen a beach or the sky before, well we may just have to use the neighbouring pixels to inform our in-filling. If we&amp;rsquo;re feeling fancy, we would look a little further afield and use that information too ( i.e. is there just sky around the area, or is there something else).&lt;/li&gt;
&lt;li&gt;Or&amp;hellip; we could look at the image as a whole and try to see what would fit best. For this we would have to use our knowledge of similar scenes we&amp;rsquo;ve observed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is the difference between using (1) contextual and (2) perceptual information. But before we look more heavily into this, let&amp;rsquo;s take a look at the idea behind a GAN.&lt;/p&gt;

&lt;h2 id=&#34;gan&#34;&gt; Generative Adversarial Networks &lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ve said that there are two components in a GAN, the &lt;em&gt;generator&lt;/em&gt; and the &lt;em&gt;discriminator&lt;/em&gt;. Here, we&amp;rsquo;ll look more closely at what they do.&lt;/p&gt;

&lt;p&gt;Our purpose is to create images which are as realistic as possible. So much so, that they are able to fool not only humans, but the computer that has generated them. You will often see GANs being compared to money counterfeiting: our generator is trying to create fake money whilst our discriminator is trying to tell the difference between the real and fake bills. How does this work?&lt;/p&gt;

&lt;p&gt;Say we have an image $x$ which our discriminator $D$ is analysing. $D(x)$ gives a low value near to 0 if the image looks normal or &amp;lsquo;natural&amp;rsquo; and a higher value near to 1 if it thinks the image is fake - this could mean it is very noisy for example. The generator $G$ takes a vector $z$ that has been randomly sampled from a very simple, but well known, distribution e.g. a uniform or normal distribution. The image that is produced by $G(z)$ should help to train the function at $D$. We alternate showing the discriminator a real image (which will change its parameters to give a low output) and then an image from $G$ (which will change $D$ to give a higher output). At the same time, we want $G$ to also be learning to produce more realistic images which are more likely to fool $D$. We want $G$ to &lt;em&gt;minimise&lt;/em&gt; the output of $D$ whilst $D$ is trying to &lt;em&gt;maximise&lt;/em&gt; the same thing. They are playing a &lt;a href=&#34;https://en.wikipedia.org/wiki/Minimax&#34; title=&#34;Wiki: minimax&#34;&gt;&amp;lsquo;minimax&amp;rsquo;&lt;/a&gt; game against each other, which is where we get the term &amp;lsquo;adversarial&amp;rsquo; training.&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;/img/CNN/gan1.png&#34; width=&#34;100%&#34; alt=&#34;GAN&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 2&lt;/font&gt;: Generative Adversarial Network concept. Simple, known distribution $p_z$ from which the vector $z$ is drawn. Generator $G(z)$ generates an image. Discriminator tries to determine if image came from $G$ or from the true, unknown distribution $p_{data}$.
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Let&amp;rsquo;s keep going with the maths&amp;hellip;&lt;/p&gt;

&lt;p&gt;This kind of network has a lot of latent (hidden) variables that need to be found. But we can start from a strong position by using a distribution that we know very well like a uniform distribution.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;known&lt;/strong&gt; distribution we denote $p_z$ We will randomly draw a vector $z$ from $p_z$.&lt;/li&gt;
&lt;li&gt;We know that our data must have some distribution but we do &lt;strong&gt;not&lt;/strong&gt; know this. We&amp;rsquo;ll call this $p_{data}$&lt;/li&gt;
&lt;li&gt;Our generator will try to learn its own distribution $p_g$. Our goal is for $p_g = p_{data}$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have two networks to train, $D$ and $G$:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We want to &lt;em&gt;minimise&lt;/em&gt; $D(x)$ if $x$ is drawn from our true distribution $p_{data}$ i.e. &lt;em&gt;minimise&lt;/em&gt; $D(x)$ if it&amp;rsquo;s not.&lt;/li&gt;
&lt;li&gt;and &lt;em&gt;maximise&lt;/em&gt; $D(G(z))$ i.e. &lt;em&gt;minimise&lt;/em&gt; $1 - D(G(z))$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More formally:&lt;/p&gt;

&lt;div&gt;$$
\min_{G}\max_{D} V(D, G) = \mathbb{E}_{x\sim p_{data}} \left[ \log D(x)  \right]+ \mathbb{E}_{z\sim p_{z}} \left[ \log \left( 1 - D(G(z)) \right) \right]

$$
&lt;/div&gt;

&lt;p&gt;Where $\mathbb{E}$ is the expectation. The advantage of working with neural networks is that we can easily compute gradients and use backpropagation to perform training. This is because the generator and the discriminator are defined by the multi-layer perceptron (MLP) parameters $\theta_g$ and $\theta_d$ respectively.&lt;/p&gt;

&lt;p&gt;We will train the networks (the $G$ and the $D$) one at a time, fixing the weights of one whilst training the other. From the GAN Goodfellow &lt;em&gt;et al&lt;/em&gt; we get the &lt;em&gt;pseudo&lt;/em&gt; code for this procedure:&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;/img/CNN/ganalgorithm.png&#34; width=&#34;100%&#34; alt=&#34;GAN&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 3&lt;/font&gt;: &lt;i&gt;pseudo&lt;/i&gt; code for GAN training. With $k=1$ this equates to training $D$ then $G$ one after the other. Adapted from &lt;a href=&#34;https://arxiv.org/pdf/1406.2661&#34; title=&#34;Goodfellow et al. 2014&#34;&gt;Goodfellow &lt;i&gt;et al.&lt;/i&gt; 2014&lt;/a&gt;.
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Notice that with $k=1$ we are training $D$ then $G$ one after the other. What is the training actually doing? Fig. 4 shows the distribution $p_g$ of the generator in green. Notice that with each training step, the $p_g$ becomes more like the true distribution of the image data $p_{data}$ in black. After each alternation, the error is backpropagated to udate the weights on the network that is not being held fixed. The discriminator eventually reaches its &lt;em&gt;lowest maximum&lt;/em&gt; where it is no longer able to tell the difference between the true and fake images.&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;/img/CNN/ganalgographs.png&#34; width=&#34;100%&#34; alt=&#34;GAN&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 4&lt;/font&gt;: Initially (a) the generator&#39;s and true data distributions (green and black) are not very similar. (b) the discriminator (blue) is updated with generator held constant. (c) Generator is updated with discriminator held constant, until (d) $p_g$ and $p_{data}$ are most alike. Adapted from &lt;a href=&#34;https://arxiv.org/pdf/1406.2661&#34; title=&#34;Goodfellow et al. 2014&#34;&gt;Goodfellow &lt;i&gt;et al.&lt;/i&gt; 2014&lt;/a&gt;.
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;nextsteps&#34;&gt; What&#39;s Next?&#34;&lt;/h2&gt;

&lt;p&gt;That really is it. The basics of a GAN are just a game between two networks, the generator $G$, which produces images from some latent variables $z$, and the discriminator $D$ which tries to detect the faked images.&lt;/p&gt;

&lt;p&gt;Implementing this in Python seems old-hat to many and there are many pre-build solutions available. The work in this tutorial series will mostly follow the base-code from &lt;a href=&#34;https://github.com/carpedm20/DCGAN-tensorflow&#34; title=&#34;carpedm20/DCGAN-tensorflow&#34;&gt;carpedm20&amp;rsquo;s DCGAN-tensorflow repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the next post, we&amp;rsquo;ll get ourselves organised, make sure we have some dependencies, create some files and get our training data sorted.&lt;/p&gt;

&lt;p&gt;As always, if there&amp;rsquo;s anything wrong or that doesn&amp;rsquo;t make send &lt;strong&gt;please&lt;/strong&gt; get in contact and let me know. A comment here is great.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Convolutional Neural Networks - TensorFlow (Basics)</title>
      <link>/post/tensorflow-basics/</link>
      <pubDate>Mon, 03 Jul 2017 09:44:24 +0100</pubDate>
      
      <guid>/post/tensorflow-basics/</guid>
      <description>&lt;p&gt;We&amp;rsquo;ve looked at the principles behind how a CNN works, but how do we actually implement this in Python? This tutorial will look at the basic idea behind Google&amp;rsquo;s TensorFlow: an efficient way to build a CNN using purpose-build Python libraries.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;div style=&#34;text-align:center;&#34;&gt;&lt;img width=30% title=&#34;TensorFlow&#34; src=&#34;/img/CNN/TF_logo.png&#34;&gt;&lt;/div&gt;

&lt;h2 id=&#34;intro&#34;&gt;  Introduction &lt;/h2&gt;

&lt;p&gt;Building a CNN from scratch in Python is perfectly possible, but very memory intensive. It can also lead to very long pieces of code. Several libraries have been developed by the community to solve this problem by wrapping the most common parts of CNNs into special methods called from their own libraries. Theano, Keras and Caffe are notable libraries being used today that are all opensource. However, since TensorFlow was released and Google announced their machine-learning-specific hardware, the Tensor Processing Unit (TPU), TensorFlow has quickly become a much-used tool in the field. If any applications being built today are intended for use on mobile devices, TensorFlow is the way to go as the mobile TPU in the upcoming Google phones will be able to perform inference from machine learning models in the User&amp;rsquo;s hand. Of course, being a relative newcomer and very much still controlled by Google, TensorFlow may not have the huge body of support that has built up with Theano, say.&lt;/p&gt;

&lt;p&gt;Nevertheless, TensorFlow is powerful and quick to setup so long as you know how: read on to find out. Much of this tutorial is based around the documentation provided by Google, but gives a lot more information that many be useful to less experienced users.&lt;/p&gt;

&lt;h2 id=&#34;install&#34;&gt; Installation &lt;/h2&gt;

&lt;p&gt;TensorFlow is just another set of Python libraries distributed by Google via the website: &lt;a href=&#34;https://www.tensorflow.org/install&#34; title=&#34;TensorFlow Installation&#34;&gt;https://www.tensorflow.org/install&lt;/a&gt;. There&amp;rsquo;s the option to install the version for use on GPUs but that&amp;rsquo;s not necessary for this tutorial, we&amp;rsquo;ll be using the MNIST dataset which is not too memory instensive.&lt;/p&gt;

&lt;p&gt;Go ahead and install the TensorFlow libraries. I would say that even though they suggest using TF in a virtual environment, we will be coding up our CNN in a Python script so don&amp;rsquo;t worry about that if you&amp;rsquo;re not comfortable with it.&lt;/p&gt;

&lt;p&gt;One of the most frustrating things you will find with TF is that much of the documentation on various websites is already out-of-date. Some of the commands have been re-written or renamed since the support was put in place. Even some of Google&amp;rsquo;s own tutorials are now old and require tweaking. Nonetheless, the code written here will work on all versions, but may throw some &amp;lsquo;depreication&amp;rsquo; warnings.&lt;/p&gt;

&lt;h2 id=&#34;structure&#34;&gt; TensorFlow Structure &lt;/h2&gt;

&lt;p&gt;The idea of &amp;lsquo;flow&amp;rsquo; is central to TF&amp;rsquo;s organisation. The actual CNN is written as a &amp;lsquo;graph&amp;rsquo;. A graph is simply a list of the differnet layers in your network each with their own input and output. Whatever data we input at the top will &amp;lsquo;flow&amp;rsquo; through the graph and output some values. The values we will also deal with using TensorFlow which will automatically take care of the updating of any internal weights via whatever optimization method and loss function we prefer.&lt;/p&gt;

&lt;p&gt;The graph is called by some initial functions in the script that create the classifier, run the training and output whatever evlauation metrics we like.&lt;/p&gt;

&lt;p&gt;Before writing any functions, lets import the necessary includes and tell TF to limit any program logging:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
import os
import tensorflow as tf
from tensorflow.contrib import learn
from tensorflow.contrib.learn.python.learn.estimators import model_fn as model_fn_lib


os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] = &#39;3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve included multiple Tf lines to save on the typing later.&lt;/p&gt;

&lt;h3 id=&#34;graph&#34;&gt; The Graph &lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get straight to it and start to build our graph. We will keep it simple:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2 convolutional layers learning 16 filters (or kernels) of [3 x 3]&lt;/li&gt;
&lt;li&gt;2 max-pooling layers that half the size of the image using [2 x 2] kernel&lt;/li&gt;
&lt;li&gt;A fully connected layer at the end.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Hyperparameters
numK = 16               #number of kernels in each conv layer
sizeConvK = 3           #size of the kernels in each conv layer [n x n]
sizePoolK = 2           #size of the kernels in each pool layer [m x m]
inputSize = 28          #size of the input image
numChannels = 1         #number of channels to the input image grayscale=1, RGB=3

def convNet(inputs, labels, mode):
    #reshape the input from a vector to a 2D image
    input_layer = tf.reshape(inputs, [-1, inputSize, inputSize, numChannels])   
    
    #perform convolution and pooling
    conv1 = doConv(input_layer) 
    pool1 = doPool(conv1)      
    
    conv2 = doConv(pool1)
    pool2 = doPool(conv2)

    #flatted the result back to a vector for the FC layer
    flatPool = tf.reshape(pool2, [-1, 7 * 7 * numK])    
    dense = tf.layers.dense(inputs=flatPool, units=1024, activation=tf.nn.relu)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what&amp;rsquo;s going on here? First we&amp;rsquo;ve defined some parameters for the CNN such as kernel sizes, the height of the input image (assuming it&amp;rsquo;s square) and the number of channels for the image. The number of channels is &lt;code&gt;1&lt;/code&gt; for both Black and White with intensity values of either 0 or 1, and grayscale images with intensities in the range [0 255]. Colour images have &lt;code&gt;3&lt;/code&gt; channels, Red, Green and Blue.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice that we&amp;rsquo;ve barely used TF so far: we use it to reshape the data. This is important, when we run our script, TF will take our raw data and turn it into its own data type i.e. a &lt;code&gt;tensor&lt;/code&gt;. That means our normal &lt;code&gt;numpy&lt;/code&gt; operations won&amp;rsquo;t work on them so we should use the in-built &lt;code&gt;tf.reshape&lt;/code&gt; function which works in the same was as the one in numpy - it takes the input data and an output shape as arguments.&lt;/p&gt;

&lt;p&gt;But why are we reshaping at all? Well, the data that is input into the network will be in the form of vectors. The image will have been saved along with lots of other images as single lines of a larger file. This is the case with the MNIST dataset and is common in machine learning. So we need to put it back into image-form so that we can perform convolutions.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Where are those random 7s and the -1 from?&amp;rdquo;&amp;hellip; good question. In this example, we are going to be using the MNIST dataset whose images are 28 x 28. If we put this through 2 pooling layers we will half (14 x 14) and half again (7 x 7) the width. Thus the layer needs to know what it is expecting the output to look like based upon the input which will be a 7 x 7 x &lt;code&gt;numK&lt;/code&gt; tensor, one 7 x 7 for each kernel. Keep in mind that we will be running the network with more than one input image at a time, so in reality when we get to this stage, there will be &lt;code&gt;n&lt;/code&gt; images here which all have 7 x 7 x &lt;code&gt;numK&lt;/code&gt; values associated with them. The -1 simply tells TensorFlow to take &lt;em&gt;all&lt;/em&gt; of these images and do the same to each. It&amp;rsquo;s short hand for &amp;ldquo;do this for the whole batch&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also a &lt;code&gt;tf.layers.dense&lt;/code&gt; method at the end here. This is one of TF&amp;rsquo;s in-built layer types that is very handy. We just tell it what to take as input, how many units we want it to have and what non-linearity we would prefer at the end. Instead of typing this all separately, it&amp;rsquo;s combined into a single line. Neat!&lt;/p&gt;

&lt;p&gt;But what about the &lt;code&gt;conv&lt;/code&gt; and &lt;code&gt;pool&lt;/code&gt; layers? Well, to keep the code nice and tidy, I like to write the convolution and pooling layers in separate functions. This means that if I want to add more &lt;code&gt;conv&lt;/code&gt; or &lt;code&gt;pool&lt;/code&gt; layers, I can just write them in underneath the current ones and the code will still look clean (not that the functions are very long). Here they are:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def doConv(inputs):
    convOut = tf.layers.conv2d(inputs=inputs, filters=numK, kernel_size=[sizeConvK, sizeConvK], \
    	padding=&amp;quot;same&amp;quot;, activation=tf.nn.relu)    
    return convOut
    
def doPool(inputs):
    poolOut = tf.layers.max_pooling2d(inputs=inputs, pool_size=[sizePoolK, sizePoolK], strides=2)
    return poolOut
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, both the &lt;code&gt;conv&lt;/code&gt; and &lt;code&gt;pool&lt;/code&gt; layers are simple one-liners. They both take in some input data and need to know the size of the kernel you want them to use (which we defined earlier on). The &lt;code&gt;conv&lt;/code&gt; layer need to know how many &lt;code&gt;filters&lt;/code&gt; to learn too. Alongside this, we need to take care of any mis-match between the image size and the size of the kernels to ensure that we&amp;rsquo;re not changing the size of the image when we get the output. This is easily done in TF by setting the &lt;code&gt;padding&lt;/code&gt; attribute to &lt;code&gt;&amp;quot;same&amp;quot;&lt;/code&gt;. We&amp;rsquo;ve got our non-linearity at the end here too. We&amp;rsquo;ve hard-coded that the pooling layer will have &lt;code&gt;strides=2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we have the main part of our network coded-up. But it wont do very much unless we ask TF to give us some outputs and compare them to some training data.&lt;/p&gt;

&lt;p&gt;As the MNIST data is used for image-classification problems, we&amp;rsquo;ll be trying to get the network to output probabilities that the image it is given belong to a specific class i.e. a number 0-9. The MNIST dataset only provides the numbers 0-9 which, if we provided this to the network, would start to output guesses of decimal values 0.143, 4.765, 8.112 or whatever. We need to change this data so that each class can have its own specific box which the network can assign a probability. We use the idea of &amp;lsquo;one-hot&amp;rsquo; labels for this. For example, class 3 becomes [0 0 0 1 0 0 0 0 0 0] and class 9 becomes [0 0 0 0 0 0 0 0 0 1]. This way we&amp;rsquo;re not asking the network to predict the number associated with each class but rather how likely is the test-image to be in this class.&lt;/p&gt;

&lt;p&gt;TF has a very handy function for changing class labels into &amp;lsquo;one-hot&amp;rsquo; labels. Let&amp;rsquo;s continue coding our graph in the &lt;code&gt;convNet&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;     #Get the output in the form of one-hot labels with x units
    logits = tf.layers.dense(inputs=dense, units=10) 
    
    loss = None
    train_op = None
    #At the end of the network, check how well we did     
    if mode != learn.ModeKeys.INFER:
        #create one-hot tabels from the training-labels
        onehot_labels = tf.one_hot(indices=tf.cast(labels, tf.int32), depth=10)
        #check how close the output is to the training-labels
        loss = tf.losses.softmax_cross_entropy(onehot_labels=onehot_labels, logits=logits)
    
    #After checking the loss, use it to train the network weights   
    if mode == learn.ModeKeys.TRAIN:
        train_op = tf.contrib.layers.optimize_loss(loss=loss, global_step=tf.contrib.framework.get_global_step(), \
            learning_rate=learning_rate, optimizer=&amp;quot;SGD&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;logits&lt;/code&gt; here is the output of the network which corresponds to the 10 classes of the training labels. The next two sections check whether we should be training the weights right now, or checking how well we&amp;rsquo;ve done. First we check our progress: we use &lt;code&gt;tf.one_hot&lt;/code&gt; to create the one-hot labels form the numeric training labels given to the network in &lt;code&gt;labels&lt;/code&gt;. We&amp;rsquo;ve performed a &lt;code&gt;tf.cast&lt;/code&gt; operation to make sure that the data is of the correct type before doing the conversion.&lt;/p&gt;

&lt;p&gt;Our loss-function is an important part of a CNN (or any machine learning algorithm). There are many different loss functions already built-in with TensorFlow from simple &lt;code&gt;absolute_difference&lt;/code&gt; to more complex functions like our &lt;code&gt;softmax_cross_entropy&lt;/code&gt;. We won&amp;rsquo;t delve into how this is calculated, just know that we can pick any loss function. More advanced users can write their own loss-functions. The loss function takes in the output of the network &lt;code&gt;logits&lt;/code&gt; and compares it to our &lt;code&gt;onehot_labels&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When this is done, we ask TF to perform some updating or &amp;lsquo;optimization&amp;rsquo; of the network based on the loss that we just calculated. the &lt;code&gt;train_op&lt;/code&gt; in TF is the name given in support documnets to the function that performs any background changes to the fundamentals of the network or updates values. Our &lt;code&gt;train_op&lt;/code&gt; here is a simple loss-optimiser that tries to find the minimum loss for our data. As with all machine learning algorithms, the parameters of this optimiser are subject to much research. Using a pre-build optimiser such as those included with TF will ensure that your network performs efficiently and trains as quickly as possible. The &lt;code&gt;learning_rate&lt;/code&gt; can be set as a variable at the beginning of our script along with the other parameters. We tend to stick with &lt;code&gt;0.001&lt;/code&gt; to begin with and move in orders of magnitude if we need to e.g. &lt;code&gt;0.01&lt;/code&gt; or &lt;code&gt;0.0001&lt;/code&gt;. Just like the loss functions, there are a number of optimisers to use, some will take longer than others if they are more complex. For our purposes on the MNIST dataset, simple stochastic gradient descent (&lt;code&gt;SGD&lt;/code&gt;) will suffice.&lt;/p&gt;

&lt;p&gt;Notice that we are literally just giving TF some instructions: take my network, calculate the loss and do some optimisation based on that loss. There is very little back-end programming involved with TF.&lt;/p&gt;

&lt;p&gt;We are going to want to show what the network has learned, so we output the current predictions by definiing a dictionary of data. The raw logits information and the associated probabilities (found by taking the softmax of the logits tensor).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;predictions ={&amp;quot;classes&amp;quot;: tf.argmax(input=logits, axis=1), &amp;quot;probabilities&amp;quot;: tf.nn.softmax(logits, name=&amp;quot;softmax_tensor&amp;quot;)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can finish off our graph by making sure it returns the data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return model_fn_lib.ModelFnOps(mode=mode, predictions=predictions, loss=loss, train_op=train_op)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ModelFnOps&lt;/code&gt; class is returns that contains the current mode of the network (training or inference), the current predictions, loss and the &lt;code&gt;train_op&lt;/code&gt; that we use to train the network.&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Setting up the Script&lt;/h3&gt;

&lt;p&gt;Now that the graph has been constructed, we need to call it and tell TF to do the training. First, lets take a moment to load the data the we will be using. The MNIST dataset has its own loading method within TF (handy!). Let&amp;rsquo;s define the main body of our script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def main(unused_argv):
    # Load training and eval data
    mnist = learn.datasets.load_dataset(&amp;quot;mnist&amp;quot;)
    train_data = mnist.train.images # Returns np.array
    train_labels = np.asarray(mnist.train.labels, dtype=np.int32)
    eval_data = mnist.test.images # Returns np.array
    eval_labels = np.asarray(mnist.test.labels, dtype=np.int32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we create the classifier that will hold the network and all of its data. We have to tell it what our graph is called under &lt;code&gt;model_fn&lt;/code&gt; and where we would like our output stored.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you use the &lt;code&gt;/tmp&lt;/code&gt; directory in Linux you will probably find that the model will no longer be there if you restart your computer. If you intend to reload and use your model later on, be sure to save it in a more conventient place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    mnistClassifier = learn.Estimator(model_fn=convNet,   model_dir=&amp;quot;/tmp/mln_MNIST&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will want to get some information out of our network that tells us about the training performance. For example, we can create a dictionary that will hold the probabilities from the key that we named &amp;lsquo;softmax_tensor&amp;rsquo; in the graph. How often we save this information is controlled with the &lt;code&gt;every_n_iter&lt;/code&gt; attricute. We add this to the &lt;code&gt;tf.train.LoggingTensorHook&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    tensors2log = {&amp;quot;probabilities&amp;quot;: &amp;quot;softmax_tensor&amp;quot;}
    logging_hook = tf.train.LoggingTensorHook(tensors=tensors2log, every_n_iter=100)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally! Let&amp;rsquo;s get TF to actually train the network. We call the &lt;code&gt;.fit&lt;/code&gt; method of the classifier that we created earlier. We pass it the training data and the labels along with the batch size (i.e. how much of the training data we want to use in each iteration). Bare in mind that even though the MNIST images are very small, there are 60,000 of them and this may not do well for your RAM. We also need to say what the maximum number of iterations we&amp;rsquo;d like TF to perform is and also add on that we want to &lt;code&gt;monitor&lt;/code&gt; the training by outputting the data we&amp;rsquo;ve requested in &lt;code&gt;logging_hook&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    mnistClassifier.fit(x=train_data, y=train_labels, batch_size=100, steps=1000, monitors=[logging_hook])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the training is complete, we&amp;rsquo;d like TF to take some test-data and tell us how well the network performs. So we create a special metrics dictionary that TF will populate by calling the &lt;code&gt;.evaluate&lt;/code&gt; method of the classifier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    metrics = {&amp;quot;accuracy&amp;quot;: learn.MetricSpec(metric_fn=tf.metrics.accuracy, prediction_key=&amp;quot;classes&amp;quot;)}
    
    eval_results = mnistClassifier.evaluate(x=eval_data, y=eval_labels, metrics=metrics)
    print(eval_results)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we&amp;rsquo;ve chosen to find the accuracy of the classifier by using the &lt;code&gt;tf.metrics.accuracy&lt;/code&gt; value for the &lt;code&gt;metric_fn&lt;/code&gt;. We also need to tell the evaluator that it&amp;rsquo;s the &amp;lsquo;classes&amp;rsquo; key we&amp;rsquo;re looking at in the graph. This is then passed to the evaluator along with the test data.&lt;/p&gt;

&lt;h3 id=&#34;running&#34;&gt;Running the Network&lt;/h3&gt;

&lt;p&gt;Adding the final main function to the script and making sure we&amp;rsquo;ve done all the necessary includes, we can run the program. The full script can be found &lt;a href=&#34;/docs/tfCNNMNIST.py&#34; title=&#34;TFCNNMNIST.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the current configuration, running the network for 1000 epochs gave me an output of:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{&#39;loss&#39;: 1.9025836, &#39;global_step&#39;: 1000, &#39;accuracy&#39;: 0.64929998}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Definitely not a great accuracy for the MNIST dataset! We could just run this for longer and would likely see an increase in accuracy, Instead, lets make some of the easy tweaks to our network that we&amp;rsquo;ve described before: dropout and batch normalisation.&lt;/p&gt;

&lt;p&gt;In our graph, we want to add:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    dense = tf.contrib.layers.batch_norm(dense, decay=0.99, is_training= mode==learn.ModeKeys.TRAIN)
    dense = tf.layers.dropout(inputs=dense, rate=keepProb, training = mode==learn.ModeKeys.TRAIN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This layer &lt;a href=&#34;https://www.tensorflow.org/api_docs/python/tf/contrib/layers/batch_norm&#34; title=&#34;tf.contrib.layers.batch_norm&#34;&gt;has many different attirbutes&lt;/a&gt;. It&amp;rsquo;s functionality is taken from &lt;a href=&#34;https://arxiv.org/abs/1502.03167&#34; title=&#34;Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift&#34;&gt;the paper by Loffe and Szegedy (2015)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dropout layer&amp;rsquo;s &lt;code&gt;keepProb&lt;/code&gt; is defined in the Hyperparameter pramble to the script. Another value that can be changed to improve the performance of the network. Both of these lines are in the final script &lt;a href=&#34;/docs/tfCNNMNIST.py&#34; title=&#34;tffCNNMNIST.py&#34;&gt;available here&lt;/a&gt;, just uncomment them.&lt;/p&gt;

&lt;p&gt;If we re-run the script, it will automatically load the most recent state of the network (clever TensorFlow!) but&amp;hellip; it will fail because the checkpoint does not include the two new layers in its graph. So we must either delete our &lt;code&gt;/tmp/mln_MNIST&lt;/code&gt; folder, or give the classifier a new &lt;code&gt;model_dir&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Doing this and rerunning for the same 1000 epochs, I get an instant 140% increase in accuracy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{&#39;loss&#39;: 0.29391664, &#39;global_step&#39;: 1000, &#39;accuracy&#39;: 0.91680002}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simply changing the optimiser to use the &amp;ldquo;Adam&amp;rdquo; rather than &amp;ldquo;SGD&amp;rdquo; optimiser yields:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{&#39;loss&#39;: 0.040745325, &#39;global_step&#39;: 1000, &#39;accuracy&#39;: 0.98500001}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And running for slightly longer (20,000 iterations);&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{&#39;loss&#39;: 0.046967514, &#39;global_step&#39;: 20000, &#39;accuracy&#39;: 0.99129999}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt; Conclusion &lt;/h2&gt;

&lt;p&gt;TensorFlow takes away the tedium of having to write out the full code for each individual layer and is able to perform optimisation and evaluation with minimal effort.&lt;/p&gt;

&lt;p&gt;If you look around online, you will see many methods for using TF that will get you similar results. I actually prefer some methods that are a little more explicit. The tutorial on Google for example has some room to allow us to including more logging features.&lt;/p&gt;

&lt;p&gt;In future posts, we will look more into logging and TensorBoard, but for now, happy coding!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Convolutional Neural Networks - Basics</title>
      <link>/post/CNN1/</link>
      <pubDate>Fri, 07 Apr 2017 09:46:56 +0100</pubDate>
      
      <guid>/post/CNN1/</guid>
      <description>&lt;p&gt;This series will give some background to CNNs, their architecture, coding and tuning. In particular, this tutorial covers some of the background to CNNs and Deep Learning. We won&amp;rsquo;t go over any coding in this session, but that will come in the next one. What&amp;rsquo;s the big deal about CNNs? What do they look like? Why do they work? Find out in this tutorial.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;intro&#34;&gt;  Introduction &lt;/h2&gt;

&lt;p&gt;A convolutional neural network (CNN) is very much related to the standard NN we&amp;rsquo;ve previously encountered. I found that when I searched for the link between the two, there seemed to be no natural progression from one to the other in terms of tutorials. It would seem that CNNs were developed in the late 1980s and then forgotten about due to the lack of processing power. In fact, it wasn&amp;rsquo;t until the advent of cheap, but powerful GPUs (graphics cards) that the research on CNNs and Deep Learning in general was given new life. Thus you&amp;rsquo;ll find an explosion of papers on CNNs in the last 3 or 4 years.&lt;/p&gt;

&lt;p&gt;Nonetheless, the research that has been churned out is &lt;em&gt;powerful&lt;/em&gt;. CNNs are used in so many applications now:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object recognition in images and videos (think image-search in Google, tagging friends faces in Facebook, adding filters in Snapchat and tracking movement in Kinect)&lt;/li&gt;
&lt;li&gt;Natural language processing (speech recognition in Google Assistant or Amazon&amp;rsquo;s Alexa)&lt;/li&gt;
&lt;li&gt;Playing games (the recent &lt;a href=&#34;https://en.wikipedia.org/wiki/AlphaGo&#34; title=&#34;AlphaGo on Wiki&#34;&gt;defeat of the world &amp;lsquo;Go&amp;rsquo; champion&lt;/a&gt; by DeepMind at Google)&lt;/li&gt;
&lt;li&gt;Medical innovation (from drug discovery to prediction of disease)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dispite the differences between these applications and the ever-increasing sophistication of CNNs, they all start out in the same way. Let&amp;rsquo;s take a look.&lt;/p&gt;

&lt;h2 id=&#34;deep&#34;&gt;  CNN or Deep Learning? &lt;/h2&gt;

&lt;p&gt;
You would be forgiven for thinking that Deep Learning (DL) takes its name from the number of layers in a neural network, but the root is a little more complex than that. In fact, some powerful neural networks, even CNNs, only consist of a few layers. The &#39;deep&#39; in DL acknowledges that each layer of the network has &#39;layers&#39; of its own. More on this later.
&lt;/p&gt;&lt;p&gt;
Often you may see a conflation of CNNs with DL, but the concept of DL comes some time before CNNs were first introduced. Connecting multiple neural networks together, altering the directionality of their weights and stacking such machines all gave rise to the increasing power and popularity of DL.
&lt;/p&gt;&lt;p&gt;
We won&#39;t delve too deeply into history or mathematics in this tutorial, but if you want to know the timeline of DL in more detail, I&#39;d suggest the paper &#34;On the Origin of Deep Learning&#34; (Wang and Raj 2016) available &lt;a href=&#34;https://t.co/aAw4rEpZEt&#34; title=&#34;On the Origin of Deep Learning&#34;&gt;here&lt;/a&gt;. It&#39;s a lengthy read - 72 pages including references - but shows the logic between progressive steps in DL.
&lt;/p&gt;&lt;p&gt;
As with the study of neural networks, the inspiration for CNNs came from nature: specifically, the visual cortex. It drew upon the idea that the neurons in the visual cortex focus upon different sized patches of an image getting different levels of information in different layers. If a computer could be programmed to work in this way, it may be able to mimic the image-recognition power of the brain. So how can this be done?
&lt;/p&gt;

&lt;p&gt;A CNN takes as input an array, or image (2D or 3D, grayscale or colour) and tries to learn the relationship between this image and some target data e.g. a classification. By &amp;lsquo;learn&amp;rsquo; we are still talking about weights just like in a regular neural network. The difference in CNNs is that these weights connect small subsections of the input to each of the different neurons in the first layer. Fundamentally, there are multiple neurons in a single layer that each have their own weights to the same subsection of the input. These different sets of weights are called &amp;lsquo;kernels&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important at this stage to make sure we understand this weight or kernel business, because it&amp;rsquo;s the whole point of the &amp;lsquo;convolution&amp;rsquo; bit of the CNN.&lt;/p&gt;

&lt;h2 id=&#34;kernels&#34;&gt; Convolution and Kernels &lt;/h2&gt;

&lt;p&gt;Convolution is something that should be taught in schools along with addition, and multiplication - it&amp;rsquo;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Convolution&#34; title=&#34;Convolution on Wiki&#34;&gt;just another mathematical operation&lt;/a&gt;. Perhaps the reason it&amp;rsquo;s not, is because it&amp;rsquo;s a little more difficult to visualise.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we have a pattern or a stamp that we want to repeat at regular intervals on a sheet of paper, a very convenient way to do this is to perform a convolution of the pattern with a regular grid on the paper. Think about hovering the stamp (or kernel) above the paper and moving it along a grid before pushing it into the page at each interval.&lt;/p&gt;

&lt;p&gt;This idea of wanting to repeat a pattern (kernel) across some domain comes up a lot in the realm of signal processing and computer vision. In fact, if you&amp;rsquo;ve ever used a graphics package such as Photoshop, Inkscape or GIMP, you&amp;rsquo;ll have seen many kernels before. The list of &amp;lsquo;filters&amp;rsquo; such as &amp;lsquo;blur&amp;rsquo;, &amp;lsquo;sharpen&amp;rsquo; and &amp;lsquo;edge-detection&amp;rsquo; are all done with a convolution of a kernel or filter with the image that you&amp;rsquo;re looking at.&lt;/p&gt;

&lt;p&gt;For example, let&amp;rsquo;s find the outline (edges) of the image &amp;lsquo;A&amp;rsquo;.&lt;/p&gt;

&lt;div style=&#34;text-align:center; display:inline-block; width:100%; margin:auto;&#34;&gt;
&lt;img title=&#34;Android&#34; src=&#34;/img/CNN/android.png&#34;&gt;&lt;br&gt;
&lt;b&gt;A&lt;/b&gt;
&lt;/div&gt;

&lt;p&gt;We can use a kernel, or set of weights, like the ones below.&lt;/p&gt;

&lt;div style=&#34;width:100%; text-align:center;&#34;&gt;
&lt;div style=&#34;text-align:center; display:inline-block; width:49%; margin:auto;min-width:155px;&#34;&gt;
&lt;img title=&#34;Horizontal Filter&#34; height=150 src=&#34;/img/CNN/horizFilter.png&#34;&gt;&lt;br&gt;
&lt;b&gt;Finds horizontals&lt;/b&gt;
&lt;/div&gt;
&lt;div style=&#34;text-align:center; min-width:150px;display:inline-block; width:49%;margin:auto;&#34;&gt;
&lt;img title=&#34;Vertical Filter&#34; height=150 src=&#34;/img/CNN/vertFilter.png&#34;&gt;&lt;br&gt;
&lt;b&gt;Finds verticals&lt;/b&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;A kernel is placed in the top-left corner of the image. The pixel values covered by the kernel are multiplied with the corresponing kernel values and the products are summated. The result is placed in the new image at the point corresponding the centre of the kernel. An example for this first step is shown in the diagram below. This takes the vertical Sobel filter (used for edge-detection) and applies it to the pixels of the image.&lt;/p&gt;

&lt;div style=&#34;text-align:center; display:inline-block; width:100%;margin:auto;&#34;&gt;
&lt;img title=&#34;Conv Example&#34; height=&#34;350&#34; src=&#34;/img/CNN/convExample.png&#34;&gt;&lt;br&gt;
&lt;b&gt;A step in the Convolution Process.&lt;/b&gt;
&lt;/div&gt;

&lt;p&gt;The kernel is moved over by one pixel and this process is repated until all of the possible locations in the image are filtered as below, this time for the horizontal Sobel filter. Notice that there is a border of empty values around the convolved image. This is because the result of convolution is placed at the centre of the kernel. To deal with this, a process called &amp;lsquo;padding&amp;rsquo; or more commonly &amp;lsquo;zero-padding&amp;rsquo; is used. This simply means that a border of zeros is places around the original image to make it a pixel wider all around. The convolution is then done as normal, but the convolution result will now produce an image that is of equal size to the original.&lt;/p&gt;

&lt;div style=&#34;width:100%;margin:auto; text-align:center;&#34;&gt;
&lt;div style=&#34;text-align:center; display:inline-block; width:45%;min-width:455px;margin:auto;&#34;&gt;
&lt;img title=&#34;Sobel Conv Gif&#34; height=&#34;450&#34; src=&#34;/img/CNN/convSobel.gif&#34;&gt;&lt;br&gt;
&lt;b&gt;The kernel is moved over the image performing the convolution as it goes.&lt;/b&gt;
&lt;/div&gt;
&lt;div style=&#34;text-align:center; display:inline-block; width:45%;min-width:450px;margin:auto;&#34;&gt;
&lt;img title=&#34;Zero Padding Conv&#34; height=&#34;450&#34; src=&#34;/img/CNN/convZeros.png&#34;&gt;&lt;br&gt;
&lt;b&gt;Zero-padding is used so that the resulting image doesn&#39;t shrink.&lt;/b&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Now that we have our convolved image, we can use a colourmap to visualise the result. Here, I&amp;rsquo;ve just normalised the values between 0 and 255 so that I can apply a grayscale visualisation:&lt;/p&gt;

&lt;div style=&#34;text-align:center; display:inline-block; width:100%;margin:auto;&#34;&gt;
&lt;img title=&#34;Conv Result&#34; height=&#34;150&#34;src=&#34;/img/CNN/convResult.png&#34;&gt;&lt;br&gt;
&lt;b&gt;Result of the convolution&lt;/b&gt;
&lt;/div&gt;

&lt;p&gt;This dummy example could represent the very bottom left edge of the Android&amp;rsquo;s head and doesn&amp;rsquo;t really look like it&amp;rsquo;s detected anything. To see the proper effect, we need to scale this up so that we&amp;rsquo;re not looking at individual pixels. Performing the horizontal and vertical sobel filtering on the full 264 x 264 image gives:&lt;/p&gt;

&lt;div style=&#34;width:100%;margin:auto; text-align:center;&#34;&gt;
&lt;div style=&#34;text-align:center; display:inline-block; min-width:100px;margin:auto;&#34;&gt;
&lt;img title=&#34;Horizontal Sobel&#34; src=&#34;/img/CNN/horiz.png&#34;&gt;&lt;br&gt;
&lt;b&gt;Horizontal Sobel&lt;/b&gt;
&lt;/div&gt;
&lt;div style=&#34;text-align:center; display:inline-block; margin:auto;min-width:100px&#34;&gt;
&lt;img title=&#34;Vertical Sobel&#34; src=&#34;/img/CNN/vert.png&#34;&gt;&lt;br&gt;
&lt;b&gt;Vertical Sobel&lt;/b&gt;
&lt;/div&gt;
&lt;div style=&#34;text-align:center; display:inline-block;margin:auto;min-width:100px&#34;&gt;
&lt;img title=&#34;Full Sobel&#34; src=&#34;/img/CNN/both.png&#34;&gt;&lt;br&gt;
&lt;b&gt;Combined Sobel&lt;/b&gt;
&lt;/div&gt;  
&lt;/div&gt;

&lt;p&gt;Where we&amp;rsquo;ve also added together the result from both filters to get both the horizontal and vertical ones.&lt;/p&gt;

&lt;h3 id=&#34;relationship&#34;&gt; How does this feed into CNNs? &lt;/h3&gt;

&lt;p&gt;Clearly, convolution is powerful in finding the features of an image &lt;strong&gt;if&lt;/strong&gt; we already know the right kernel to use. Kernel design is an artform and has been refined over the last few decades to do some pretty amazing things with images (just look at the huge list in your graphics software!). But the important question is, what if we don&amp;rsquo;t know the features we&amp;rsquo;re looking for? Or what if we &lt;strong&gt;do&lt;/strong&gt; know, but we don&amp;rsquo;t know what the kernel should look like?&lt;/p&gt;

&lt;p&gt;Well, first we should recognise that every pixel in an image is a &lt;strong&gt;feature&lt;/strong&gt; and that means it represents an &lt;strong&gt;input node&lt;/strong&gt;. The result from each convolution is placed into the next layer in a &lt;strong&gt;hidden node&lt;/strong&gt;. Each feature or pixel of the convolved image is a node in the hidden layer.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve already said that each of these numbers in the kernel is a weight, and that weight is the connection between the feature of the input image and the node of the hidden layer. The kernel is swept across the image and so there must be as many hidden nodes as there are input nodes (well actually slightly fewer as we should add zero-padding to the input image). This means that the hidden layer is also 2D like the input image. Sometimes, instead of moving the kernel over one pixel at a time, the &lt;strong&gt;stride&lt;/strong&gt;, as it&amp;rsquo;s called, can be increased. This will result in fewer nodes or fewer pixels in the convolved image. Consider it like this:&lt;/p&gt;

&lt;div style=&#34;width:100%;margin:auto; text-align:center;&#34;&gt;
&lt;div style=&#34;text-align:center; display:inline-block;margin:auto;min-width:300px;&#34;&gt;
&lt;img title=&#34;Hidden Layer Nodes&#34; height=300 src=&#34;/img/CNN/hiddenLayer.png&#34;&gt;&lt;br&gt;
&lt;b&gt;Hidden Layer Nodes in a CNN&lt;/b&gt;
&lt;/div&gt;  
&lt;div style=&#34;text-align:center; display:inline-block;margin:auto;min-width:300px&#34;&gt;
&lt;img title=&#34;Hidden Layer after Increased Stride&#34; height=225 src=&#34;/img/CNN/strideHidden.png&#34;&gt;&lt;br&gt;
&lt;b&gt;Increased stride means fewer hidden-layer nodes&lt;/b&gt;
&lt;/div&gt;  
&lt;/div&gt;

&lt;p&gt;These weights that connect to the nodes need to be learned in exactly the same way as in a regular neural network. The image is passed through these nodes (by being convolved with the weights a.k.a the kernel) and the result is compared to some output (the error of which is then backpropagated and optimised).&lt;/p&gt;

&lt;p&gt;In reality, it isn&amp;rsquo;t just the weights or the kernel for one 2D set of nodes that has to be learned, there is a whole array of nodes which all look at the same area of the image (called the &lt;strong&gt;receptive field&lt;/strong&gt;*). Each of the nodes in this row (or &lt;strong&gt;fibre&lt;/strong&gt;) tries to learn different kernels (different weights) that will show up some different features of the image, like edges. So the hidden-layer may look something more like this:&lt;/p&gt;

&lt;p&gt;* &lt;em&gt;Note: we&amp;rsquo;ll talk more about the receptive field after looking at the pooling layer below&lt;/em&gt;&lt;/p&gt;

&lt;div style=&#34;width:100%;margin:auto; text-align:center;&#34;&gt;
&lt;div style=&#34;text-align:center; display:inline-block;margin:auto;min-width:100px&#34;&gt;
&lt;img title=&#34;Multiple Kernel Hidden Layer&#34; height=350 src=&#34;/img/CNN/deepConv.png&#34;&gt;&lt;br&gt;
&lt;b&gt;For a 2D image learning a set of kernels.&lt;/b&gt;
&lt;/div&gt;
&lt;div style=&#34;text-align:center; display:inline-block;margin:auto;min-width:100px&#34;&gt;
&lt;img title=&#34;3 Channel Image&#34; height=350 src=&#34;/img/CNN/deepConv3.png&#34;&gt;&lt;br&gt;
&lt;b&gt;For a 3 channel RGB image the kernel becomes 3D.&lt;/b&gt; 
&lt;/div&gt;
&lt;/div&gt;  

&lt;p&gt;Now &lt;strong&gt;this&lt;/strong&gt; is why deep learning is called &lt;strong&gt;deep&lt;/strong&gt; learning. Each hidden layer of the convolutional neural network is capable of learning a large number of kernels. The output from this hidden-layer is passed to more layers which are able to learn their own kernels based on the &lt;em&gt;convolved&lt;/em&gt; image output from this layer. This is what gives the CNN the ability to see the edges of an image and build them up into larger features.&lt;/p&gt;

&lt;h2 id=&#34;CNN Architecture&#34;&gt;  CNN Archiecture &lt;/h2&gt;

&lt;p&gt;It is the &lt;em&gt;architecture&lt;/em&gt; of a CNN that gives it its power. In fact, most papers that are puplished these days on CNNs tend to be about a new achitecture i.e. the number and ordering of different layers and how many kernels are learnt. Let&amp;rsquo;s take a look at the other layers in a CNN.&lt;/p&gt;

&lt;h2 id=&#39;layers&#39;&gt; Layers &lt;/h2&gt;

&lt;h3 id=&#34;input&#34;&gt;  Input Layer &lt;/h3&gt;

&lt;p&gt;The input image is placed into this layer. It can be a single-layer 2D image (grayscale), 2D 3-channel image (RGB colour) or 3D. The main different between how the inputs are arranged comes in the formation of the expected kernel shapes. Kernels need to be learned that are the same depth as the input i.e. 5 x 5 x 3 for a 2D RGB image with a receptive field of 5 x 5.&lt;/p&gt;

&lt;p&gt;Input to a CNN seem to work best when they&amp;rsquo;re of certain dimensions. This is because of the behviour of the convolution. Depending on the &lt;em&gt;stride&lt;/em&gt; of the kernel and the subsequent &lt;em&gt;pooling layers&lt;/em&gt; the outputs may become an &amp;ldquo;illegal&amp;rdquo; size including half-pixels. We&amp;rsquo;ll look at this in the &lt;em&gt;pooling layer&lt;/em&gt; section.&lt;/p&gt;

&lt;h3 id=&#34;convolution&#34;&gt;  Convolutional Layer &lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve &lt;a href=&#34;#kernels&#34; title=&#34;Convolution and Kernels&#34;&gt;already looked at what the conv layer does&lt;/a&gt;. Just remember that it takes in an image e.g. [56 x 56 x 3] and assuming a stride of 1 and zero-padding, will produce an output of [56 x 56 x 32] if 32 kernels are being learnt. It&amp;rsquo;s important to note that the order of these dimensions can be important during the implementation of a CNN in Python. This is because there&amp;rsquo;s alot of matrix multiplication going on!&lt;/p&gt;

&lt;h3 id=&#34;nonlinear&#34;&gt; Non-linearity&lt;/h3&gt;

&lt;p&gt;The &amp;lsquo;non-linearity&amp;rsquo; here isn&amp;rsquo;t its own distinct layer of the CNN, but comes as part of the convolution layer as it is done in the neurons (just like a normal NN). By this, we mean &amp;ldquo;don&amp;rsquo;t take the data forwards as it is (linearity) let&amp;rsquo;s do something to it (non-linearlity) that will help us later on&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;In our neural network tutorials we looked at different &lt;a href=&#34;/post/transfer-functions&#34; title=&#34;Transfer Functions&#34;&gt;activation functions&lt;/a&gt;. These each provide a different mapping of the input to an output, either to [-1 1], [0 1] or some other domain e.g the Rectified Linear Unit thresholds the data at 0: max(0,x). The &lt;em&gt;ReLU&lt;/em&gt; is very popular as it doesn&amp;rsquo;t require any expensive computation and it&amp;rsquo;s been &lt;a href=&#34;http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf&#34; title=&#34;Krizhevsky et al 2012&#34;&gt;shown to speed up the convergence of stochastic gradient descent algorithms&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;pool&#34;&gt;  Pooling Layer &lt;/h3&gt;

&lt;p&gt;The pooling layer is key to making sure that the subsequent layers of the CNN are able to pick up larger-scale detail than just edges and curves. It does this by merging pixel regions in the convolved image together (shrinking the image) before attempting to learn kernels on it. Effectlively, this stage tages another kernel, say [2 x 2] and passes it over the entire image, just like in convolution. It is common to have the stride and kernal size equal i.e. a [2 x 2] kernel has a stride of 2. This example will &lt;em&gt;half&lt;/em&gt; the size of the convolved image. The number of feature-maps produced by the learned kernels will remain the same as &lt;strong&gt;pooling&lt;/strong&gt; is done on each one in turn. Thus the pooling layer returns an array with the same depth as the convolution layer. The figure below shows the principal.&lt;/p&gt;

&lt;div style=&#34;text-align:center; display:inline-block; width:100%;margin:auto;&#34;&gt;
&lt;img title=&#34;Pooling&#34; height=350 src=&#34;/img/CNN/poolfig.gif&#34;&gt;&lt;br&gt;
&lt;b&gt;Max-pooling: Pooling using a &#34;max&#34; filter with stride equal to the kernel size&lt;/b&gt;
&lt;/div&gt;  

&lt;h3 id=&#34;receptiveField&#34;&gt; A Note on the Receptive Field &lt;/h3&gt;

&lt;p&gt;This is quite an important, but sometimes neglected, concept. We said that the receptive field of a single neuron is the area of the image which is can &amp;lsquo;see&amp;rsquo;. Each neuron has a different receptive field. While this is true, the full impact of it can only be understood when we see what happens after pooling.&lt;/p&gt;

&lt;p&gt;For an image of size [12 x 12], say the receptive field (kernel size) in the first conv layer is [3 x 3]. The output of the conv layer (assuming padding and stride of 1) is going to be the [12 x 12 x 10] if we&amp;rsquo;re learning 10 kernels. After pooling with a [3 x 3] kernel, we get an output of [4 x 4 x 10]. This gets fed into the next conv layer. Suppose the kernel in the second conv layer is [2 x 2], would we say that the receptive field here is also [2 x 2]? Well, yes&amp;hellip; but actually, no. In fact, a neuron in this layer is not just seeing the [2 x 2] area of the &lt;em&gt;convolved&lt;/em&gt; image, it is actually seeing a [4 x 4] area of the &lt;em&gt;original&lt;/em&gt; image. That&amp;rsquo;s the [3 x 3] of the first layer for each of the pixels in the &amp;lsquo;receptive field&amp;rsquo; of the second layer (remembering we had a stride of 1 in the first layer). Continuing this through the rest of the network, it is possible to end up with a final layer with a recpetive field equal to the size of the original image. Understanding this gives us the real insight to how the CNN works, building up the image as it goes.&lt;/p&gt;

&lt;h3 id=&#34;dense&#34;&gt;  Fully-connected (Dense) Layer&lt;/h3&gt;

&lt;p&gt;So this layer took me a while to figure out. If I take all of the say [3 x 3 x 64] featuremaps of my final pooling layer I have 3 x 3 x 64 = 576 different weights to consider and update. What I need is to make sure that my training labels match with the outputs from my output layer. We may only have 10 possibilities in our output layer (say the digits 0 - 9 ). Thus we want the final numbers in our output layer to be [? x 10] where the ? represents the number of nodes in the layer before&amp;hellip; this one, the FC layer. If there was only 1 node in this layer, it would have 576 weights attached to it - one for each of the weights coming from the previous pooling layer. This is not very useful as it won&amp;rsquo;t allow us to learn any combinations of these low-dimensional outputs. Increasing the number of neurons to say 1,000+ will allow the FC layer to provide many different combinations of features and learn a potentially non-linear function that represents the feature space. The larger the FC layer, the more complex the function could be (though it may not need to be very big). Sometimes it&amp;rsquo;s seen that there are two FC layers together, this just increases the possibility of learning a complex function. FC layers are 1D vectors.&lt;/p&gt;

&lt;h4 id = &#34;fcConv&#34;&gt; Fully-connected as a Convolutional Layer &lt;/h4&gt;

&lt;p&gt;If the idea above doesn&amp;rsquo;t help you (as it doesn&amp;rsquo;t for me) lets remove the FC layer and replace it with another convolutional layer. This is very simple - take the output from the pooling layer as before and apply a convolution to it with a kernel that is the same size as a featuremap in the pooling layer. For this to be of use, the input to the conv should be down to around [5 x 5] or [3 x 3] by making sure there have been enough pooling layers in the network. What does this achieve? By convolving a [3 x 3] image with a [3 x 3] kernel we get a 1 pixel output. There is no striding, just one convolution per featuremap. So out output from this layer will be a [1 x k] vector where &lt;em&gt;k&lt;/em&gt; is the number of featuremaps. This is very similar to the FC layer, except that the output from the conv is only created from an individual featuremap rather than being connected to all of the featuremaps. This can be powerfulll though as we have represented a very large receptive field by a single pixel. We&amp;rsquo;re able to say, if the value of the output it high, that all of the featuremaps visible to this output have activated enough to represent a &amp;lsquo;cat&amp;rsquo; or whatever it is we are training our network to learn.&lt;/p&gt;

&lt;p&gt;Often, the kernel used in the final layer of a CNN incorporates some average pooling. Considering this as not just an average of the current featuremaps, but all previous featuremaps, then the output will be high if the previous layers were active within the receptive field of the final layer.&lt;/p&gt;

&lt;h3 id=&#34;dropout&#34;&gt; Dropout Layer &lt;/h3&gt;

&lt;p&gt;The previously mentioned fully-connected layer is connected to all weights in the previous layer - this can be a very large number. As such, an FC layer is prone to &lt;em&gt;overfitting&lt;/em&gt; meaning that the network won&amp;rsquo;t generalise well to new data. There are a number of techniques that can be used to reduce overfitting though the most commonly seen in CNNs is the dropout layer. As the name suggests, this causes the network to &amp;lsquo;drop&amp;rsquo; some nodes on each iteration with a particular probability. The &lt;em&gt;keep probability&lt;/em&gt; is between 0 and 1, most commonly around 0.2-0.5 it seems. This is the probability that a particular node is dropped during training. When back propagation occurs, the weights connected to these nodes are not updated. They are readded for the next iteration.&lt;/p&gt;

&lt;h3 id=&#34;output&#34;&gt; Output Layer &lt;/h3&gt;

&lt;p&gt;Of course depending on the purpose of your CNN, the output layer will be slightly different. In general, the output layer consists of a number of nodes which have a high value if they are &amp;lsquo;true&amp;rsquo; or activated. Consider a classification problem where a CNN is given a set of images containing cats, dogs and elephants. If we&amp;rsquo;re asking the CNN to learn what a cat, dog and elephant looks like, output layer is going to be a set of three nodes, one for each &amp;lsquo;class&amp;rsquo; or animal. We&amp;rsquo;d expect that when the CNN finds an image of a cat, the value at the node representing &amp;lsquo;cat&amp;rsquo; is higher than the other two. This is the same idea as in a regular neural network. In fact, the FC layer and the output layer can be considered as a traditional NN. Some output layers are probabilities and as such will sum to 1, whilst others will just achieve a value which could be a pixel intensity in the range 0-255.&lt;/p&gt;

&lt;h3 id=&#34;backProp&#34;&gt; A Note on Back Propagation &lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve found it helpful to consider CNNs in reverse. It didn&amp;rsquo;t sit properly in my mind that the CNN first learns all different types of edges, curves etc. and then builds them up into large features e.g. a face. It came up in a discussion that we could consider the CNN working in reverse, and in fact this is effectively what happens - back propagation updates the weights from the final layer &lt;em&gt;back&lt;/em&gt; towards the first. In fact, the error (or loss) minimisation occurs firstly at the final layer and as such, this is where the network is &amp;lsquo;seeing&amp;rsquo; the bigger picture. The gradient (updates to the weights) vanishes towards the input layer and is greatest at the output layer. We can effectively think that the CNN is learning &amp;ldquo;face - has eyes, nose mouth&amp;rdquo; at the output layer, then &amp;ldquo;I don&amp;rsquo;t know what a face is, but here are some eyes, noses, mouths&amp;rdquo; in the previous one, then &amp;ldquo;What are eyes? I&amp;rsquo;m only seeing circles, some white bits and a black hole&amp;rdquo; followed by &amp;ldquo;woohoo! round things!&amp;rdquo; and initially by &amp;ldquo;I think that&amp;rsquo;s what a line looks like&amp;rdquo;. Possibly we could think of the CNN as being less sure about life at the first layers and being more advanced at the end.&lt;/p&gt;

&lt;p&gt;CNNs can be used for segmentation, classification, regression and a whole manner of other processes. On the whole, they only differ by four things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;architecture (number and order of conv, pool and fc layers plus the size and number of the kernels)&lt;/li&gt;
&lt;li&gt;output (probabilitstic etc.)&lt;/li&gt;
&lt;li&gt;training method (cost or loss function, regularisation and optimiser)&lt;/li&gt;
&lt;li&gt;hyperparameters (learning rate, regularisation weights, batch size, iterations&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There may well be other posts which consider these kinds of things in more detail, but for now I hope you have some insight into how CNNs function. Now, lets code it up&amp;hellip;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>