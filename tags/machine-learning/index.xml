<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Machine Learning on Machine Learning Notebook</title>
    <link>/tags/machine-learning/index.xml</link>
    <description>Recent content in Machine Learning on Machine Learning Notebook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/tags/machine-learning/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Generative Adversarial Network (GAN) in TensorFlow - Part 1</title>
      <link>/post/GAN1/</link>
      <pubDate>Tue, 11 Jul 2017 09:15:54 +0100</pubDate>
      
      <guid>/post/GAN1/</guid>
      <description>&lt;p&gt;We&amp;rsquo;ve seen that CNNs can learn the content of an image for classificationi purposes, but what else can they do? This tutorial will look at the Generative Adversarial Network (GAN) which is able to learn from a set of images and create an entirely new &amp;lsquo;fake&amp;rsquo; image which isn&amp;rsquo;t in the training set. Why? By the end of this tutorial you&amp;rsquo;ll get know why this might be done and how to do it.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;intro&#34;&gt;  Introduction &lt;/h2&gt;

&lt;p&gt;Generative Adversarial Networks (GANs) were proposed by Ian Goodfellow &lt;em&gt;et al&lt;/em&gt; in 2014 at annual the Neural Information and Processing Systems (NIPS) conference. The original paper &lt;a href=&#34;https://arxiv.org/pdf/1406.2661 &amp;quot;Generative Adversarial Nets (2014&#34;&gt;is available on Arxiv&lt;/a&gt;&amp;rdquo;) along with a later tutorial by Goodfellow delivered at NIPS in 2016 &lt;a href=&#34;https://arxiv.org/pdf/1701.00160&#34; title=&#34;NIPS 2016 Tutorial: Generative Adversarial Networks&#34;&gt;here&lt;/a&gt;. I&amp;rsquo;ve read both of these (and others) as well as taking a look at other tutorials but sometimes things just weren&amp;rsquo;t clear enough for me. &lt;a href=&#34;http://bamos.github.io/2016/08/09/deep-completion/#ml-heavy-generative-adversarial-net-gan-building-blocks&#34; title=&#34;bamos.github.io&#34;&gt;This blog from B. Amos&lt;/a&gt; has been helpful in getting my thoughts organised on this series, and hopefully I can build on this a little and make things more concrete.&lt;/p&gt;

&lt;h3&gt;What&#39;s a GAN?&lt;/h3&gt;

&lt;p&gt;GANs  are used in a number of ways, for example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;to generate new images based upon some training data. For our tutorial, we will train with a database of faces and ask the network to produce a new face.&lt;/li&gt;
&lt;li&gt;to do &amp;lsquo;inpainting&amp;rsquo; or &amp;lsquo;image completion&amp;rsquo;. This is where part of a scene may be missing and we wish to recover the full image. It could be that we want to remove parts of the image e.g. people, and fill-in the background.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are two components in a GAN which try to work against each other (hence the &amp;lsquo;adversarial&amp;rsquo; part).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Generator (&lt;em&gt;G&lt;/em&gt;) starts off by creating a very noisy image based upon some random input data. Its job is to try to come up with images that are as real as possible.&lt;/li&gt;
&lt;li&gt;The Discriminator (&lt;em&gt;D&lt;/em&gt;) is trying to determine whether an image is real or fake.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Though these two are the primary components of the network, we also need to write some functions for importing data and dealing with the training of this two-stage network. Part 1 of this tutorial will go through some background and mathematics, in Part 2 we will do some general housekeeping and get us prepared to write the main model of our network in Part 3.&lt;/p&gt;

&lt;h2 id=&#34;maths&#34;&gt; Background &lt;/h2&gt;

&lt;p&gt;There are a number of situations where you may want to use a GAN. A common task is for image completion or &amp;lsquo;in-painting&amp;rsquo;. This would be where we have an image and would like to remove some obstruction or imperfection by replacing it with the background. Maybe there&amp;rsquo;s a lovely holiday photo of beautiful scenery, but there are some people you don&amp;rsquo;t know spoiling the view. Figure 1 shows an example of the result of image completion using PhotoShop on such an image.&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;https://farm5.staticflickr.com/4115/4756059924_e26ae12e46_b.jpg&#34; width=&#34;100%&#34; alt=&#34;Image Completion Example&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 1&lt;/font&gt;: Removal of unwated parts of a scene with image completion. Source: &lt;a href=&#34;https://www.flickr.com/photos/littleredelf/4756059924/in/photostream/&#34; alt=&#34;littleredelf&#34;&gt;Flickr:littleredelf&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;We have a couple of options if we want to try and do this kind of image completion ourselves. Let&amp;rsquo;s say we draw around an area we want to change:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If we&amp;rsquo;ve never seen a beach or the sky before, well we may just have to use the neighbouring pixels to inform our in-filling. If we&amp;rsquo;re feeling fancy, we would look a little further afield and use that information too ( i.e. is there just sky around the area, or is there something else).&lt;/li&gt;
&lt;li&gt;Or&amp;hellip; we could look at the image as a whole and try to see what would fit best. For this we would have to use our knowledge of similar scenes we&amp;rsquo;ve observed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is the difference between using (1) contextual and (2) perceptual information. But before we look more heavily into this, let&amp;rsquo;s take a look at the idea behind a GAN.&lt;/p&gt;

&lt;h2 id=&#34;gan&#34;&gt; Generative Adversarial Networks &lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ve said that there are two components in a GAN, the &lt;em&gt;generator&lt;/em&gt; and the &lt;em&gt;discriminator&lt;/em&gt;. Here, we&amp;rsquo;ll look more closely at what they do.&lt;/p&gt;

&lt;p&gt;Our purpose is to create images which are as realistic as possible. So much so, that they are able to fool not only humans, but the computer that has generated them. You will often see GANs being compared to money counterfeiting: our generator is trying to create fake money whilst our discriminator is trying to tell the difference between the real and fake bills. How does this work?&lt;/p&gt;

&lt;p&gt;Say we have an image $x$ which our discriminator $D$ is analysing. $D(x)$ gives a low value near to 0 if the image looks normal or &amp;lsquo;natural&amp;rsquo; and a higher value near to 1 if it thinks the image is fake - this could mean it is very noisy for example. The generator $G$ takes a vector $z$ that has been randomly sampled from a very simple, but well known, distribution e.g. a uniform or normal distribution. The image that is produced by $G(z)$ should help to train the function at $D$. We alternate showing the discriminator a real image (which will change its parameters to give a low output) and then an image from $G$ (which will change $D$ to give a higher output). At the same time, we want $G$ to also be learning to produce more realistic images which are more likely to fool $D$. We want $G$ to &lt;em&gt;minimise&lt;/em&gt; the output of $D$ whilst $D$ is trying to &lt;em&gt;maximise&lt;/em&gt; the same thing. They are playing a &lt;a href=&#34;https://en.wikipedia.org/wiki/Minimax&#34; title=&#34;Wiki: minimax&#34;&gt;&amp;lsquo;minimax&amp;rsquo;&lt;/a&gt; game against each other, which is where we get the term &amp;lsquo;adversarial&amp;rsquo; training.&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;/img/CNN/gan1.png&#34; width=&#34;100%&#34; alt=&#34;GAN&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 2&lt;/font&gt;: Generative Adversarial Network concept. Simple, known distribution $p_z$ from which the vector $z$ is drawn. Generator $G(z)$ generates an image. Discriminator tries to determine if image came from $G$ or from the true, unknown distribution $p_{data}$.
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Let&amp;rsquo;s keep going with the maths&amp;hellip;&lt;/p&gt;

&lt;p&gt;This kind of network has a lot of latent (hidden) variables that need to be found. But we can start from a strong position by using a distribution that we know very well like a uniform distribution.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;known&lt;/strong&gt; distribution we denote $p_z$ We will randomly draw a vector $z$ from $p_z$.&lt;/li&gt;
&lt;li&gt;We know that our data must have some distribution but we do &lt;strong&gt;not&lt;/strong&gt; know this. We&amp;rsquo;ll call this $p_{data}$&lt;/li&gt;
&lt;li&gt;Our generator will try to learn its own distribution $p_g$. Our goal is for $p_g = p_{data}$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have two networks to train, $D$ and $G$:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We want to &lt;em&gt;minimise&lt;/em&gt; $D(x)$ if $x$ is drawn from our true distribution $p_{data}$ i.e. &lt;em&gt;minimise&lt;/em&gt; $D(x)$ if it&amp;rsquo;s not.&lt;/li&gt;
&lt;li&gt;and &lt;em&gt;maximise&lt;/em&gt; $D(G(z))$ i.e. &lt;em&gt;minimise&lt;/em&gt; $1 - D(G(z))$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More formally:&lt;/p&gt;

&lt;div&gt;$$
\min_{G}\max_{D} V(D, G) = \mathbb{E}_{x\sim p_{data}} \left[ \log D(x)  \right]+ \mathbb{E}_{z\sim p_{z}} \left[ \log \left( 1 - D(G(z)) \right) \right]

$$
&lt;/div&gt;

&lt;p&gt;Where $\mathbb{E}$ is the expectation. The advantage of working with neural networks is that we can easily compute gradients and use backpropagation to perform training. This is because the generator and the discriminator are defined by the multi-layer perceptron (MLP) parameters $\theta_g$ and $\theta_d$ respectively.&lt;/p&gt;

&lt;p&gt;We will train the networks (the $G$ and the $D$) one at a time, fixing the weights of one whilst training the other. From the GAN Goodfellow &lt;em&gt;et al&lt;/em&gt; we get the &lt;em&gt;pseudo&lt;/em&gt; code for this procedure:&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;/img/CNN/ganalgorithm.png&#34; width=&#34;100%&#34; alt=&#34;GAN&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 3&lt;/font&gt;: &lt;i&gt;pseudo&lt;/i&gt; code for GAN training. With $k=1$ this equates to training $D$ then $G$ one after the other. Adapted from &lt;a href=&#34;https://arxiv.org/pdf/1406.2661&#34; title=&#34;Goodfellow et al. 2014&#34;&gt;Goodfellow &lt;i&gt;et al.&lt;/i&gt; 2014&lt;/a&gt;.
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Notice that with $k=1$ we are training $D$ then $G$ one after the other. What is the training actually doing? Fig. 4 shows the distribution $p_g$ of the generator in green. Notice that with each training step, the $p_g$ becomes more like the true distribution of the image data $p_{data}$ in black. After each alternation, the error is backpropagated to udate the weights on the network that is not being held fixed. The discriminator eventually reaches its &lt;em&gt;lowest maximum&lt;/em&gt; where it is no longer able to tell the difference between the true and fake images.&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img src=&#34;/img/CNN/ganalgographs.png&#34; width=&#34;100%&#34; alt=&#34;GAN&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 4&lt;/font&gt;: Initially (a) the generator&#39;s and true data distributions (green and black) are not very similar. (b) the discriminator (blue) is updated with generator held constant. (c) Generator is updated with discriminator held constant, until (d) $p_g$ and $p_{data}$ are most alike. Adapted from &lt;a href=&#34;https://arxiv.org/pdf/1406.2661&#34; title=&#34;Goodfellow et al. 2014&#34;&gt;Goodfellow &lt;i&gt;et al.&lt;/i&gt; 2014&lt;/a&gt;.
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;nextsteps&#34;&gt; What&#39;s Next?&#34;&lt;/h2&gt;

&lt;p&gt;That really is it. The basics of a GAN are just a game between two networks, the generator $G$, which produces images from some latent variables $z$, and the discriminator $D$ which tries to detect the faked images.&lt;/p&gt;

&lt;p&gt;Implementing this in Python seems old-hat to many and there are many pre-build solutions available. The work in this tutorial series will mostly follow the base-code from &lt;a href=&#34;https://github.com/carpedm20/DCGAN-tensorflow&#34; title=&#34;carpedm20/DCGAN-tensorflow&#34;&gt;carpedm20&amp;rsquo;s DCGAN-tensorflow repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the next post, we&amp;rsquo;ll get ourselves organised, make sure we have some dependencies, create some files and get our training data sorted.&lt;/p&gt;

&lt;p&gt;As always, if there&amp;rsquo;s anything wrong or that doesn&amp;rsquo;t make send &lt;strong&gt;please&lt;/strong&gt; get in contact and let me know. A comment here is great.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Simple Neural Network - Mathematics</title>
      <link>/post/neuralnetwork/</link>
      <pubDate>Mon, 06 Mar 2017 17:04:53 +0000</pubDate>
      
      <guid>/post/neuralnetwork/</guid>
      <description>&lt;p&gt;This is the first part of a series of tutorials on Simple Neural Networks (NN). Tutorials on neural networks (NN) can be found all over the internet. Though many of them are the same, each is written (or recorded) slightly differently. This means that I always feel like I learn something new or get a better understanding of things with every tutorial I see. I&amp;rsquo;d like to make this tutorial as clear as I can, so sometimes the maths may be simplistic, but hopefully it&amp;rsquo;ll give you a good unserstanding of what&amp;rsquo;s going on.  &lt;strong&gt;Please&lt;/strong&gt; let me know if any of the notation is incorrect or there are any mistakes - either comment or use the contact page on the left.&lt;/p&gt;

&lt;div id=&#34;toctop&#34;&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#nnarchitecture&#34;&gt;Neural Network Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#transferFunction&#34;&gt;Transfer Function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#feedforward&#34;&gt;Feed-forward&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#error&#34;&gt;Error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#backPropagationGrads&#34;&gt;Back Propagation - the Gradients&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bias&#34;&gt;Bias&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#backPropagationAlgorithm&#34;&gt;Back Propagaton - the Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;nnarchitecture&#34;&gt;1. Neural Network Architecture &lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#toctop&#34;&gt;To contents&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By now, you may well have come across diagrams which look very similar to the one below. It shows some input node, connected to some output node via an intermediate node in what is called a &amp;lsquo;hidden layer&amp;rsquo; - &amp;lsquo;hidden&amp;rsquo; because in the use of NN only the input and output is of concern to the user, the &amp;lsquo;under-the-hood&amp;rsquo; stuff may not be interesting to them. In real, high-performing NN there are usually more hidden layers.&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img title=&#34;Simple NN&#34; width=40% src=&#34;/img/simpleNN/simpleNN.png&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 1&lt;/font&gt;: A simple 2-layer NN with 2 features in the input layer, 3 nodes in the hidden layer and two nodes in the output layer.
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;When we train our network, the nodes in the hidden layer each perform a calculation using the values from the input nodes. The output of this is passed on to the nodes of the next layer. When the output hits the final layer, the &amp;lsquo;output layer&amp;rsquo;, the results are compared to the real, known outputs and some tweaking of the network is done to make the output more similar to the real results. This is done with an algorithm called &lt;em&gt;back propagation&lt;/em&gt;. Before we get there, lets take a closer look at these calculations being done by the nodes.&lt;/p&gt;

&lt;h2 id=&#34;transferFunction&#34;&gt;2. Transfer Function &lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#toctop&#34;&gt;To contents&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;At each node in the hidden and output layers of the NN, an &lt;em&gt;activation&lt;/em&gt; or &lt;em&gt;transfer&lt;/em&gt; function is executed. This function takes in the output of the previous node, and multiplies it by some &lt;em&gt;weight&lt;/em&gt;. These weights are the lines which connect the nodes. The weights that come out of one node can all be different, that is they will &lt;em&gt;activate&lt;/em&gt; different neurons. There can be many forms of the transfer function, we will first look at the &lt;em&gt;sigmoid&lt;/em&gt; transfer function as it seems traditional.&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
        &lt;img title=&#34;The sigmoid function&#34; width=50% src=&#34;/img/simpleNN/sigmoid.png&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 2&lt;/font&gt;: The sigmoid function.
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;As you can see from the figure, the sigmoid function takes any real-valued input and maps it to a real number in the range $(0 \ 1)$ - i.e. between, but not equal to, 0 and 1. We can think of this almost like saying &amp;lsquo;if the value we have maps to an output near 1, this node fires, if it maps to an output near 0, the node does not fire&amp;rsquo;. The equation for this sigmoid function is:&lt;/p&gt;

&lt;div id=&#34;eqsigmoidFunction&#34;&gt;$$
\sigma ( x ) = \frac{1}{1 + e^{-x}}
$$&lt;/div&gt;

&lt;p&gt;We need to have the derivative of this transfer function so that we can perform back propagation later on. This is the process where by the connections in the network are updated to tune the performance of the NN. We&amp;rsquo;ll talk about this in more detail later, but let&amp;rsquo;s find the derivative now.&lt;/p&gt;

&lt;div&gt;
$$
\begin{align*}
\frac{d}{dx}\sigma ( x ) &amp;= \frac{d}{dx} \left( 1 + e^{ -x }\right)^{-1}\\
&amp;=  -1 \times -e^{-x} \times \left(1 + e^{-x}\right)^{-2}= \frac{ e^{-x} }{ \left(1 + e^{-x}\right)^{2} } \\
&amp;= \frac{\left(1 + e^{-x}\right) - 1}{\left(1 + e^{-x}\right)^{2}} 
= \frac{\left(1 + e^{-x}\right) }{\left(1 + e^{-x}\right)^{2}} - \frac{1}{\left(1 + e^{-x}\right)^{2}} 
= \frac{1}{\left(1 + e^{-x}\right)} - \left( \frac{1}{\left(1 + e^{-x}\right)} \right)^{2} \\[0.5em]
&amp;= \sigma ( x ) - \sigma ( x ) ^ {2}
\end{align*}
$$&lt;/div&gt;

&lt;p&gt;Therefore, we can write the derivative of the sigmoid function as:&lt;/p&gt;

&lt;div id=&#34;eqdsigmoid&#34;&gt;$$
\sigma^{\prime}( x ) = \sigma (x ) \left( 1 - \sigma ( x ) \right)
$$&lt;/div&gt;

&lt;p&gt;The sigmoid function has the nice property that its derivative is very simple: a bonus when we want to hard-code this into our NN later on. Now that we have our activation or transfer function selected, what do we do with it?&lt;/p&gt;

&lt;h2 id=&#34;feedforward&#34;&gt;3. Feed-forward &lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#toctop&#34;&gt;To contents&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;During a feed-forward pass, the network takes in the input values and gives us some output values. To see how this is done, let&amp;rsquo;s first consider a 2-layer neural network like the one in Figure 1. Here we are going to refer to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$i$ - the $i^{\text{th}}$ node of the input layer $I$&lt;/li&gt;
&lt;li&gt;$j$ - the $j^{\text{th}}$ node of the hidden layer $J$&lt;/li&gt;
&lt;li&gt;$k$ - the $k^{\text{th}}$ node of the input layer $K$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The activation function at a node $j$ in the hidden layer takes the value:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
x_{j} &amp;= \xi_{1} w_{1j} + \xi_{2} w_{2j} \\[0.5em]
&amp;= \sum_{i \in I} \xi_{i} w_{i j}

\end{align}
$$&lt;/div&gt;

&lt;p&gt;where $\xi_{i}$ is the value of the $i^{\text{th}}$ input node and $w_{i j}$ is the weight of the connection between $i^{\text{th}}$ input node and the $j^{\text{th}}$ hidden node. &lt;strong&gt;In short:&lt;/strong&gt; at each hidden layer node, multiply each input value by the connection received by that node and add them together.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the weights are initisliased when the network is setup. Sometimes they are all set to 1, or often they&amp;rsquo;re set to some small random value.&lt;/p&gt;

&lt;p&gt;We apply the activation function on $x_{j}$ at the $j^{\text{th}}$ hidden node and get:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
\mathcal{O}_{j} &amp;= \sigma(x_{j}) \\
&amp;= \sigma(  \xi_{1} w_{1j} + \xi_{2} w_{2j})
\end{align}
$$&lt;/div&gt;

&lt;p&gt;$\mathcal{O}_{j}$ is the output of the $j^{\text{th}}$ hidden node. This is calculated for each of the $j$ nodes in the hidden layer. The resulting outputs now become the input for the next layer in the network. In our case, this is the final output later. So for each of the $k$ nodes in $K$:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
\mathcal{O}_{k} &amp;= \sigma(x_{k}) \\
&amp;= \sigma \left( \sum_{j \in J}  \mathcal{O}_{j} w_{jk}  \right)
\end{align}
$$&lt;/div&gt;

&lt;p&gt;As we&amp;rsquo;ve reached the end of the network, this is also the end of the feed-foward pass. So how well did our network do at getting the correct result $\mathcal{O}_{k}$? As this is the training phase of our network, the true results will be known an we cal calculate the error.&lt;/p&gt;

&lt;h2 id=&#34;error&#34;&gt;4. Error &lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#toctop&#34;&gt;To contents&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We measure error at the end of each foward pass. This allows us to quantify how well our network has performed in getting the correct output. Let&amp;rsquo;s define $t_{k}$ as the expected or &lt;em&gt;target&lt;/em&gt; value of the $k^{\text{th}}$ node of the output layer $K$. Then the error $E$ on the entire output is:&lt;/p&gt;

&lt;div id=&#34;eqerror&#34;&gt;$$
\text{E} = \frac{1}{2} \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right)^{2}
$$&lt;/div&gt;

&lt;p&gt;Dont&amp;rsquo; be put off by the random &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; in front there, it&amp;rsquo;s been manufactured that way to make the upcoming maths easier. The rest of this should be easy enough: get the residual (difference between the target and output values), square this to get rid of any negatives and sum this over all of the nodes in the output layer.&lt;/p&gt;

&lt;p&gt;Good! Now how does this help us? Our aim here is to find a way to tune our network such that when we do a forward pass of the input data, the output is exactly what we know it should be. But we can&amp;rsquo;t change the input data, so there are only two other things we can change:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the weights going into the activation function&lt;/li&gt;
&lt;li&gt;the activation function itself&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will indeed consider the second case in another post, but the magic of NN is all about the &lt;em&gt;weights&lt;/em&gt;. Getting each weight i.e. each connection between nodes, to be just the perfect value, is what back propagation is all about. The back propagation algorithm we will look at in the next section, but lets go ahead and set it up by considering the following: how much of this error $E$ has come from each of the weights in the network?&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re asking, what is the proportion of the error coming from each of the $W_{jk}$ connections between the nodes in layer $J$ and the output layer $K$. Or in mathematical terms:&lt;/p&gt;

&lt;div&gt;$$
\frac{\partial{\text{E}}}{\partial{W_{jk}}} =  \frac{\partial{}}{\partial{W_{jk}}}  \frac{1}{2} \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right)^{2}
$$&lt;/div&gt;

&lt;p&gt;If you&amp;rsquo;re not concerned with working out the derivative, skip this highlighted section.&lt;/p&gt;

&lt;div class=&#34;highlight_section&#34;&gt;

To tackle this we can use the following bits of knowledge: the derivative of the sum is equal to the sum of the derivatives i.e. we can move the derivative term inside of the summation:

&lt;div&gt;$$ \frac{\partial{\text{E}}}{\partial{W_{jk}}} =  \frac{1}{2} \sum_{k \in K} \frac{\partial{}}{\partial{W_{jk}}} \left( \mathcal{O}_{k} - t_{k} \right)^{2}$$&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;the weight $w_{1k}$ does not affect connection $w_{2k}$ therefore the change in $W_{jk}$ with respect to any node other than the current $k$ is zero. Thus the summation goes away:&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;$$ \frac{\partial{\text{E}}}{\partial{W_{jk}}} =  \frac{1}{2} \frac{\partial{}}{\partial{W_{jk}}}  \left( \mathcal{O}_{k} - t_{k} \right)^{2}$$&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;apply the power rule knowing that $t_{k}$ is a constant:&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;$$ 
\begin{align}
\frac{\partial{\text{E}}}{\partial{W_{jk}}} &amp;=  \frac{1}{2} \times 2 \times \left( \mathcal{O}_{k} - t_{k} \right) \frac{\partial{}}{\partial{W_{jk}}}  \left( \mathcal{O}_{k}\right) \\
 &amp;=  \left( \mathcal{O}_{k} - t_{k} \right) \frac{\partial{}}{\partial{W_{jk}}}  \left( \mathcal{O}_{k}\right)
\end{align}
$$&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;the leftover derivative is the chage in the output values with respect to the weights. Substituting $ \mathcal{O}_{k} = \sigma(x_{k}) $ and the sigmoid derivative $\sigma^{\prime}( x ) = \sigma (x ) \left( 1 - \sigma ( x ) \right)$:&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;$$ 
\frac{\partial{\text{E}}}{\partial{W_{jk}}} =  \left( \mathcal{O}_{k} - t_{k} \right) \sigma (x ) \left( 1 - \sigma ( x ) \right) \frac{\partial{}}{\partial{W_{jk}}}  \left( x_{k}\right)
$$&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;the final derivative, the input value $x_{k}$ is just $\mathcal{O}_{j} W_{jk}$ i.e. output of the previous layer times the weight to this layer. So the change in  $\mathcal{O}_{j} w_{jk}$ with respect to $w_{jk}$ just gives us the output value of the previous layer $ \mathcal{O}_{j} $ and so the full derivative becomes:&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;$$ 
\begin{align}
\frac{\partial{\text{E}}}{\partial{W_{jk}}}  &amp;=  \left( \mathcal{O}_{k} - t_{k} \right) \sigma (x ) \left( 1 - \sigma ( x ) \right) \frac{\partial{}}{\partial{W_{jk}}}  \left( \mathcal{O}_{j} W_{jk} \right) \\[0.5em]
&amp;=\left( \mathcal{O}_{k} - t_{k} \right) \sigma (x )  \left( 1 - \mathcal{O}_{k}  \right) \mathcal{O}_{j} 
\end{align}
$$&lt;/div&gt;

&lt;p&gt;We can replace the sigmoid function with the output of the layer
&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;The derivative of the error function with respect to the weights is then:&lt;/p&gt;

&lt;div id=&#34;derror&#34;&gt;$$ 
\frac{\partial{\text{E}}}{\partial{W_{jk}}}  =\left( \mathcal{O}_{k} - t_{k} \right) \mathcal{O}_{k}  \left( 1 - \mathcal{O}_{k}  \right) \mathcal{O}_{j}
$$&lt;/div&gt;

&lt;p&gt;We group the terms involving $k$ and define:&lt;/p&gt;

&lt;div&gt;$$
\delta_{k} = \mathcal{O}_{k}  \left( 1 - \mathcal{O}_{k}  \right)  \left( \mathcal{O}_{k} - t_{k} \right)
$$&lt;/div&gt;

&lt;p&gt;And therefore:&lt;/p&gt;

&lt;div id=&#34;derrorjk&#34;&gt;$$ 
\frac{\partial{\text{E}}}{\partial{W_{jk}}}  = \mathcal{O}_{j} \delta_{k} 
$$&lt;/div&gt;

&lt;p&gt;So we have an expression for the amount of error, called &amp;lsquo;deta&amp;rsquo; ($\delta_{k}$), on the weights from the nodes in $J$ to each node $k$ in $K$. But how does this help us to improve out network? We need to back propagate the error.&lt;/p&gt;

&lt;h2 id=&#34;backPropagationGrads&#34;&gt;5. Back Propagation - the gradients&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#toctop&#34;&gt;To contents&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Back propagation takes the error function we found in the previous section, uses it to calculate the error on the current layer and updates the weights to that layer by some amount.&lt;/p&gt;

&lt;p&gt;So far we&amp;rsquo;ve only looked at the error on the output layer, what about the hidden layer? This also has an error, but the error here depends on the output layer&amp;rsquo;s error too (because this is where the difference between the target $t_{k}$ and output $\mathcal{O}_{k}$ can be calculated). Lets have a look at the error on the weights of the hidden layer $W_{ij}$:&lt;/p&gt;

&lt;div&gt;$$ \frac{\partial{\text{E}}}{\partial{W_{ij}}} =  \frac{\partial{}}{\partial{W_{ij}}}  \frac{1}{2} \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right)^{2}$$&lt;/div&gt;

&lt;p&gt;Now, unlike before, we cannot just drop the summation as the derivative is not directly acting on a subscript $k$ in the summation. We should be careful to note that the output from every node in $J$ is actually connected to each of the nodes in $K$ so the summation should stay. But we can still use the same tricks as before: lets use the power rule again and move the derivative inside (because the summation is finite):&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
\frac{\partial{\text{E}}}{\partial{W_{ij}}} &amp;=  \frac{1}{2} \times 2 \times  \frac{\partial{}}{\partial{W_{ij}}}   \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right)  \mathcal{O}_{k} \\
&amp;= \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right) \frac{\partial{}}{\partial{W_{ij}}} \mathcal{O}_{k}
 \end{align}
 $$&lt;/div&gt;
 

&lt;p&gt;Again, we substitute $\mathcal{O}_{k} = \sigma( x_{k})$ and its derivative and revert back to our output notation:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
\frac{\partial{\text{E}}}{\partial{W_{ij}}} &amp;= \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right) \frac{\partial{}}{\partial{W_{ij}}} (\sigma(x_{k}) )\\
&amp;= \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right) \sigma(x_{k}) \left( 1 - \sigma(x_{k}) \right) \frac{\partial{}}{\partial{W_{ij}}} (x_{k}) \\
&amp;= \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right) \mathcal{O}_{k} \left( 1 - \mathcal{O}_{k} \right) \frac{\partial{}}{\partial{W_{ij}}} (x_{k})
 \end{align}
 $$&lt;/div&gt;
 

&lt;p&gt;This still looks familar from the output layer derivative, but now we&amp;rsquo;re struggling with the derivative of the input to $k$ i.e. $x_{k}$ with respect to the weights from $I$ to $J$. Let&amp;rsquo;s use the chain rule to break apart this derivative in terms of the output from $J$:&lt;/p&gt;

&lt;div&gt; $$
\frac{\partial{ x_{k}}}{\partial{W_{ij}}} = \frac{\partial{ x_{k}}}{\partial{\mathcal{O}_{j}}}\frac{\partial{\mathcal{O}_{j}}}{\partial{W_{ij}}}
$$&lt;/div&gt;

&lt;p&gt;The change of the input to the $k^{\text{th}}$ node with respect to the output from the $j^{\text{th}}$ node is down to a product with the weights, therefore this derivative just becomes the weights $W_{jk}$. The final derivative has nothing to do with the subscript $k$ anymore, so we&amp;rsquo;re free to move this around - lets put it at the beginning:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
\frac{\partial{\text{E}}}{\partial{W_{ij}}} &amp;= \frac{\partial{\mathcal{O}_{j}}}{\partial{W_{ij}}}  \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right) \mathcal{O}_{k} \left( 1 - \mathcal{O}_{k} \right) W_{jk}
 \end{align}
 $$&lt;/div&gt;
 

&lt;p&gt;Lets finish the derivatives, remembering that the output of the node $j$ is just $\mathcal{O}_{j} = \sigma(x_{j}) $ and we know the derivative of this function too:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
\frac{\partial{\text{E}}}{\partial{W_{ij}}} &amp;= \frac{\partial{}}{\partial{W_{ij}}}\sigma(x_{j})  \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right) \mathcal{O}_{k} \left( 1 - \mathcal{O}_{k} \right) W_{jk} \\
&amp;= \sigma(x_{j}) \left( 1 - \sigma(x_{j}) \right)  \frac{\partial{x_{j} }}{\partial{W_{ij}}} \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right) \mathcal{O}_{k} \left( 1 - \mathcal{O}_{k} \right) W_{jk} \\
&amp;= \mathcal{O}_{j} \left( 1 - \mathcal{O}_{j} \right)  \frac{\partial{x_{j} }}{\partial{W_{ij}}} \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right) \mathcal{O}_{k} \left( 1 - \mathcal{O}_{k} \right) W_{jk}
 \end{align}
 $$&lt;/div&gt;
 

&lt;p&gt;The final derivative is straightforward too, the derivative of the input to $j$ with repect to the weights is just the previous input, which in our case is $\mathcal{O}_{i}$,&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
\frac{\partial{\text{E}}}{\partial{W_{ij}}} &amp;= \mathcal{O}_{j} \left( 1 - \mathcal{O}_{j} \right)  \mathcal{O}_{i} \sum_{k \in K} \left( \mathcal{O}_{k} - t_{k} \right) \mathcal{O}_{k} \left( 1 - \mathcal{O}_{k} \right) W_{jk}
 \end{align}
 $$&lt;/div&gt;
 

&lt;p&gt;Almost there! Recall that we defined $\delta_{k}$ earlier, lets sub that in:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
\frac{\partial{\text{E}}}{\partial{W_{ij}}} &amp;= \mathcal{O}_{j} \left( 1 - \mathcal{O}_{j} \right)  \mathcal{O}_{i} \sum_{k \in K} \delta_{k} W_{jk}
 \end{align}
 $$&lt;/div&gt;
 

&lt;p&gt;To clean this up, we now define the &amp;lsquo;delta&amp;rsquo; for our hidden layer:&lt;/p&gt;

&lt;div&gt;$$
\delta_{j} = \mathcal{O}_{i} \left( 1 - \mathcal{O}_{j} \right)   \sum_{k \in K} \delta_{k} W_{jk}
$$&lt;/div&gt;

&lt;p&gt;Thus, the amount of error on each of the weights going into our hidden layer:&lt;/p&gt;

&lt;div id=&#34;derrorij&#34;&gt;$$ 
\frac{\partial{\text{E}}}{\partial{W_{ij}}}  = \mathcal{O}_{i} \delta_{j} 
$$&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the reason for the name &lt;em&gt;back&lt;/em&gt; propagation is that we must calculate the errors at the far end of the network and work backwards to be able to calculate the weights at the front.&lt;/p&gt;

&lt;h2 id=&#34;bias&#34;&gt;6.  Bias &lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#toctop&#34;&gt;To contents&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lets remind ourselves what happens inside our hidden layer nodes:&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
    &lt;img title=&#34;Simple NN&#34;  width=50% src=&#34;/img/simpleNN/nodeInsideNoBias.png&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 3&lt;/font&gt;: The insides of a hidden layer node, $j$.
    &lt;/div&gt;
&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;Each feature $\xi_{i}$ from the input layer $I$ is multiplied by some weight $w_{ij}$&lt;/li&gt;
&lt;li&gt;These are added together to get $x_{i}$ the total, weighted input from the nodes in $I$&lt;/li&gt;
&lt;li&gt;$x_{i}$ is passed through the activation, or transfer, function $\sigma(x_{i})$&lt;/li&gt;
&lt;li&gt;This gives the output $\mathcal{O}_{j}$ for each of the $j$ nodes in hidden layer $J$&lt;/li&gt;
&lt;li&gt;$\mathcal{O}_{j}$ from each of the $J$ nodes becomes $\xi_{j}$ for the next layer&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When we talk about the &lt;em&gt;bias&lt;/em&gt; term in NN, we are talking about an additional parameter that is inluded in the summation of step 2 above. The bias term is usually denoted with the symbol $\theta$ (theta). It&amp;rsquo;s function is to act as a threshold for the activation (transfer) function. It is given the value of 1 and is not connected to anything else. As such, this means that any derivative of the node&amp;rsquo;s output with respect to the bias term would just give a constant, 1. This allows us to just think of the bias term as an output from the node with the value of 1. This will be updated later during backpropagation to change the threshold at which the node fires.&lt;/p&gt;

&lt;p&gt;Lets update the equation for $x_{i}$:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
x_{i} &amp;= \xi_{1j} w_{1j} + \xi_{2j} w_{2j} + \theta_{j} \\[0.5em]
\sigma( x_{i} ) &amp;= \sigma \left( \sum_{i \in I} \left( \xi_{ij} w_{ij} \right) + \theta_{j} \right)
\end{align}
$$&lt;/div&gt;

&lt;p&gt;and put it on the diagram:&lt;/p&gt;

&lt;div class=&#34;figure_container&#34;&gt;
    &lt;div class=&#34;figure_images&#34;&gt;
    &lt;img title=&#34;Simple NN&#34;  width=50% src=&#34;/img/simpleNN/nodeInside.png&#34;&gt;
    &lt;/div&gt;
    &lt;div class=&#34;figure_caption&#34;&gt;
        &lt;font color=&#34;blue&#34;&gt;Figure 3&lt;/font&gt;: The insides of a hidden layer node, $j$.
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;backPropagationAlgorithm&#34;&gt;7. Back Propagation - the algorithm&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#toctop&#34;&gt;To contents&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now we have all of the pieces! We&amp;rsquo;ve got the initial outputs after our feed-forward, we have the equations for the delta terms (the amount by which the error is based on the different weights) and we know we need to update our bias term too. So what does it look like:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Input the data into the network and feed-forward&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For each of the &lt;em&gt;output&lt;/em&gt; nodes calculate:&lt;/p&gt;

&lt;div&gt;$$
\delta_{k} = \mathcal{O}_{k}  \left( 1 - \mathcal{O}_{k}  \right)  \left( \mathcal{O}_{k} - t_{k} \right)
$$&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For each of the &lt;em&gt;hidden layer&lt;/em&gt; nodes calculate:&lt;/p&gt;

&lt;div&gt;$$
\delta_{j} = \mathcal{O}_{i} \left( 1 - \mathcal{O}_{j} \right)   \sum_{k \in K} \delta_{k} W_{jk}
$$&lt;/div&gt;
    &lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calculate the changes that need to be made to the weights and bias terms:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
\Delta W &amp;= -\eta \ \delta_{l} \ \mathcal{O}_{l-1} \\
\Delta\theta &amp;= -\eta \ \delta_{l}
\end{align}
$$&lt;/div&gt;
    &lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update the weights and biases across the network:&lt;/p&gt;

&lt;div&gt;$$
\begin{align}
W + \Delta W &amp;\rightarrow W \\
\theta + \Delta\theta &amp;\rightarrow \theta
\end{align}
$$&lt;/div&gt;
    &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here, $\eta$ is just a small number that limit the size of the deltas that we compute: we don&amp;rsquo;t want the network jumping around everywhere. The $l$ subscript denotes the deltas and output for that layer $l$. That is, we compute the delta for each of the nodes in a layer and vectorise them. Thus we can compute the element-wise product with the output values of the previous layer and get our update $\Delta W$ for the weights of the current later. Similarly with the bias term.&lt;/p&gt;

&lt;p&gt;This algorithm is looped over and over until the error between the output and the target values is below some set threshold. Depending on the size of the network i.e. the number of layers and number of nodes per layer, it can take a long time to complete one &amp;lsquo;epoch&amp;rsquo; or run through of this algorithm.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Some of the ideas notation in this tutorial comes from the good videos by &lt;a href=&#34;https://www.youtube.com/playlist?list=PL29C61214F2146796&#34; title=&#34; NN Videos&#34;&gt;Ryan Harris&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>